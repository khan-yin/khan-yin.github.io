<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ykhblog 一路向北</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2021-02-20T13:48:48.703Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>whut ykh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>datawhale阿里云天池语义分割比赛-Task1 赛题理解和baseline代码</title>
    <link href="https://yoursite.com/2021/02/20/datawhale%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A9%E6%B1%A0%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E6%AF%94%E8%B5%9B-Task1-%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3%E5%92%8Cbaseline%E4%BB%A3%E7%A0%81/"/>
    <id>https://yoursite.com/2021/02/20/datawhale%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A9%E6%B1%A0%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E6%AF%94%E8%B5%9B-Task1-%E8%B5%9B%E9%A2%98%E7%90%86%E8%A7%A3%E5%92%8Cbaseline%E4%BB%A3%E7%A0%81/</id>
    <published>2021-02-20T13:44:00.000Z</published>
    <updated>2021-02-20T13:48:48.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="datawhale阿里云天池语义分割比赛-Task1-赛题理解和baseline代码"><a href="#datawhale阿里云天池语义分割比赛-Task1-赛题理解和baseline代码" class="headerlink" title="datawhale阿里云天池语义分割比赛-Task1 赛题理解和baseline代码"></a>datawhale阿里云天池语义分割比赛-Task1 赛题理解和baseline代码</h1><p>这里给出比赛地址：<a href="https://tianchi.aliyun.com/competition/entrance/531872/introduction?spm=5176.12281949.1003.10.493e3eafj1Afqc" target="_blank" rel="noopener">比赛地址</a><br>本章将对语义分割赛题进行赛题背景讲解，对赛题数据读取进行说明，并给出解题思路。</p><h2 id="1-赛题理解"><a href="#1-赛题理解" class="headerlink" title="1 赛题理解"></a>1 赛题理解</h2><a id="more"></a><ul><li>赛题名称：零基础入门语义分割-地表建筑物识别</li><li>赛题目标：通过本次赛题可以引导大家熟练掌握语义分割任务的定义，具体的解题流程和相应的模型，并掌握语义分割任务的发展。</li><li>赛题任务：赛题以计算机视觉为背景，要求选手使用给定的航拍图像训练模型并完成地表建筑物识别任务。</li></ul><h3 id="1-1-学习目标"><a href="#1-1-学习目标" class="headerlink" title="1.1 学习目标"></a>1.1 学习目标</h3><ul><li>理解赛题背景和赛题数据</li><li>完成赛题报名和数据下载，理解赛题的解题思路</li></ul><h3 id="1-2-赛题数据"><a href="#1-2-赛题数据" class="headerlink" title="1.2 赛题数据"></a>1.2 赛题数据</h3><p>遥感技术已成为获取地表覆盖信息最为行之有效的手段，遥感技术已经成功应用于地表覆盖检测、植被面积检测和建筑物检测任务。本赛题使用航拍数据，需要参赛选手完成地表建筑物识别，将地表航拍图像素划分为有建筑物和无建筑物两类。</p><p>如下图，左边为原始航拍图，右边为对应的建筑物标注。</p><p><img src="https://img-blog.csdnimg.cn/20210220213543778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>赛题数据来源（Inria Aerial Image Labeling），并进行拆分处理。数据集报名后可见并可下载。赛题数据为航拍图，需要参赛选手识别图片中的地表建筑具体像素位置。</p><h3 id="1-3-数据标签"><a href="#1-3-数据标签" class="headerlink" title="1.3 数据标签"></a>1.3 数据标签</h3><p>赛题为语义分割任务，因此具体的标签为图像像素类别。在赛题数据中像素属于2类（无建筑物和有建筑物），因此标签为有建筑物的像素。赛题原始图片为jpg格式，标签为RLE编码的字符串。</p><p>RLE全称（run-length encoding），翻译为游程编码或行程长度编码，对连续的黑、白像素数以不同的码字进行编码。RLE是一种简单的非破坏性资料压缩法，经常用在在语义分割比赛中对标签进行编码。</p><p>RLE与图片之间的转换如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rle_encode</span><span class="hljs-params">(im)</span>:</span><br>    <span class="hljs-string">'''</span><br><span class="hljs-string">    im: numpy array, 1 - mask, 0 - background</span><br><span class="hljs-string">    Returns run length as string formated</span><br><span class="hljs-string">    '''</span><br>    pixels = im.flatten(order = <span class="hljs-string">'F'</span>)<br>    pixels = np.concatenate([[<span class="hljs-number">0</span>], pixels, [<span class="hljs-number">0</span>]])<br>    runs = np.where(pixels[<span class="hljs-number">1</span>:] != pixels[:<span class="hljs-number">-1</span>])[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br>    runs[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>] -= runs[::<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>.join(str(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> runs)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rle_decode</span><span class="hljs-params">(mask_rle, shape=<span class="hljs-params">(<span class="hljs-number">512</span>, <span class="hljs-number">512</span>)</span>)</span>:</span><br>    <span class="hljs-string">'''</span><br><span class="hljs-string">    mask_rle: run-length as string formated (start length)</span><br><span class="hljs-string">    shape: (height,width) of array to return </span><br><span class="hljs-string">    Returns numpy array, 1 - mask, 0 - background</span><br><span class="hljs-string"></span><br><span class="hljs-string">    '''</span><br>    s = mask_rle.split()<br>    starts, lengths = [np.asarray(x, dtype=int) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (s[<span class="hljs-number">0</span>:][::<span class="hljs-number">2</span>], s[<span class="hljs-number">1</span>:][::<span class="hljs-number">2</span>])]<br>    starts -= <span class="hljs-number">1</span><br>    ends = starts + lengths<br>    img = np.zeros(shape[<span class="hljs-number">0</span>]*shape[<span class="hljs-number">1</span>], dtype=np.uint8)<br>    <span class="hljs-keyword">for</span> lo, hi <span class="hljs-keyword">in</span> zip(starts, ends):<br>        img[lo:hi] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> img.reshape(shape, order=<span class="hljs-string">'F'</span>)<br></code></pre></td></tr></table></figure><h3 id="rle-encode全过程分析"><a href="#rle-encode全过程分析" class="headerlink" title="rle_encode全过程分析"></a>rle_encode全过程分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">im = mask<br>pixels = im.flatten(order = <span class="hljs-string">'F'</span>)<br><br>print(pixels,len(pixels))<br>pixels = np.concatenate([[<span class="hljs-number">0</span>], pixels, [<span class="hljs-number">0</span>]])<br>print(pixels,len(pixels))<br>runs = np.where(pixels[<span class="hljs-number">1</span>:] != pixels[:<span class="hljs-number">-1</span>])[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br>print(pixels[<span class="hljs-number">1</span>:].shape)<br>print(pixels[:<span class="hljs-number">-1</span>].shape)<br>print(runs,len(runs))<br><span class="hljs-comment">##这里其实就相当于是前后错位了一个数，</span><br><span class="hljs-comment">#然后就会找到左右不同的像素点即边界，从而将所有的感兴趣点都提取出来</span><br><span class="hljs-comment">#print(runs[::2]) #每一段的start位置</span><br><span class="hljs-comment">#print(runs[1::2]) #每一段的end位置</span><br>runs[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>] -= runs[::<span class="hljs-number">2</span>] <span class="hljs-comment">#end-start即将end变成了length</span><br><span class="hljs-comment"># print(runs[1::2]) #得到每一段的长度</span><br><br>res = <span class="hljs-string">' '</span>.join(str(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> runs)<br><span class="hljs-comment"># [str(x) for x in runs]</span><br></code></pre></td></tr></table></figure><h3 id="1-4-评价指标"><a href="#1-4-评价指标" class="headerlink" title="1.4 评价指标"></a>1.4 评价指标</h3><h5 id="语义分割的相关loss介绍"><a href="#语义分割的相关loss介绍" class="headerlink" title="语义分割的相关loss介绍"></a>语义分割的相关loss介绍</h5><p><a href="https://zhuanlan.zhihu.com/p/101773544" target="_blank" rel="noopener">知乎链接</a><br>赛题使用Dice coefficient来衡量选手结果与真实标签的差异性，Dice coefficient可以按像素差异性来比较结果的差异性。Dice coefficient的具体计算方式如下：</p><p>$$<br>\frac{2 * |X \cap Y|}{|X| + |Y|}<br>$$</p><p>其中$X$是预测结果，$Y$为真实标签的结果。当$X$与$Y$完全相同时Dice coefficient为1，排行榜使用所有测试集图片的平均Dice coefficient来衡量，分数值越大越好。<br><img src="https://img-blog.csdnimg.cn/20210220213913495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1-5-读取数据"><a href="#1-5-读取数据" class="headerlink" title="1.5 读取数据"></a>1.5 读取数据</h3><table><thead><tr><th align="left">FileName</th><th align="left">Size</th><th align="right">含义</th></tr></thead><tbody><tr><td align="left">test_a.zip</td><td align="left">314.49MB</td><td align="right">测试集A榜图片</td></tr><tr><td align="left">test_a_samplesubmit.csv</td><td align="left">46.39KB</td><td align="right">测试集A榜提交样例</td></tr><tr><td align="left">train.zip</td><td align="left">3.68GB</td><td align="right">训练集图片</td></tr><tr><td align="left">train_mask.csv.zip</td><td align="left">97.52MB</td><td align="right">训练集图片标注</td></tr></tbody></table><p>具体数据读取案例：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> cv2<br>train_mask = pd.read_csv(<span class="hljs-string">'train_mask.csv'</span>, sep=<span class="hljs-string">'\t'</span>, names=[<span class="hljs-string">'name'</span>, <span class="hljs-string">'mask'</span>])<br><br><span class="hljs-comment"># 读取第一张图，并将对于的rle解码为mask矩阵</span><br>img = cv2.imread(<span class="hljs-string">'train/'</span>+ train_mask[<span class="hljs-string">'name'</span>].iloc[<span class="hljs-number">0</span>])<br>mask = rle_decode(train_mask[<span class="hljs-string">'mask'</span>].iloc[<span class="hljs-number">0</span>])<br><br>print(rle_encode(mask) == train_mask[<span class="hljs-string">'mask'</span>].iloc[<span class="hljs-number">0</span>])<br><span class="hljs-comment"># 结果为True</span><br></code></pre></td></tr></table></figure><h3 id="1-6-解题思路"><a href="#1-6-解题思路" class="headerlink" title="1.6 解题思路"></a>1.6 解题思路</h3><p>由于本次赛题是一个典型的语义分割任务，因此可以直接使用语义分割的模型来完成：</p><ul><li>步骤1：使用FCN模型模型跑通具体模型训练过程，并对结果进行预测提交；</li><li>步骤2：在现有基础上加入数据扩增方法，并划分验证集以监督模型精度；</li><li>步骤3：使用更加强大模型结构（如Unet和PSPNet）或尺寸更大的输入完成训练；</li><li>步骤4：训练多个模型完成模型集成操作；</li></ul><h3 id="1-7-本章小结"><a href="#1-7-本章小结" class="headerlink" title="1.7 本章小结"></a>1.7 本章小结</h3><p>本章主要对赛题背景和主要任务进行讲解，并多对赛题数据和标注读取方式进行介绍，最后列举了赛题解题思路。</p><h3 id="1-8-课后作业"><a href="#1-8-课后作业" class="headerlink" title="1.8 课后作业"></a>1.8 课后作业</h3><ol><li>理解RLE编码过程，并完成赛题数据读取并可视化；</li><li>统计所有图片整图中没有任何建筑物像素占所有训练集图片的比例；</li><li>统计所有图片中建筑物像素占所有相似度的比例；</li><li>统计所有图片中建筑物区域平均区域大小；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;datawhale阿里云天池语义分割比赛-Task1-赛题理解和baseline代码&quot;&gt;&lt;a href=&quot;#datawhale阿里云天池语义分割比赛-Task1-赛题理解和baseline代码&quot; class=&quot;headerlink&quot; title=&quot;datawhale阿里云天池语义分割比赛-Task1 赛题理解和baseline代码&quot;&gt;&lt;/a&gt;datawhale阿里云天池语义分割比赛-Task1 赛题理解和baseline代码&lt;/h1&gt;&lt;p&gt;这里给出比赛地址：&lt;a href=&quot;https://tianchi.aliyun.com/competition/entrance/531872/introduction?spm=5176.12281949.1003.10.493e3eafj1Afqc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;比赛地址&lt;/a&gt;&lt;br&gt;本章将对语义分割赛题进行赛题背景讲解，对赛题数据读取进行说明，并给出解题思路。&lt;/p&gt;
&lt;h2 id=&quot;1-赛题理解&quot;&gt;&lt;a href=&quot;#1-赛题理解&quot; class=&quot;headerlink&quot; title=&quot;1 赛题理解&quot;&gt;&lt;/a&gt;1 赛题理解&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="datawhale" scheme="https://yoursite.com/tags/datawhale/"/>
    
      <category term="计算机视觉" scheme="https://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>datawhale-pandas缺失数据处理</title>
    <link href="https://yoursite.com/2021/01/20/datawhale-pandas%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <id>https://yoursite.com/2021/01/20/datawhale-pandas%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</id>
    <published>2021-01-20T12:55:00.000Z</published>
    <updated>2021-02-20T13:45:36.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缺失数据"><a href="#缺失数据" class="headerlink" title="缺失数据"></a>缺失数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br></code></pre></td></tr></table></figure><h2 id="一、缺失值的统计和删除"><a href="#一、缺失值的统计和删除" class="headerlink" title="一、缺失值的统计和删除"></a>一、缺失值的统计和删除</h2><h2 id="1-缺失信息的统计"><a href="#1-缺失信息的统计" class="headerlink" title="1. 缺失信息的统计"></a>1. 缺失信息的统计</h2><p>缺失数据可以使用 <code>isna</code> 或 <code>isnull</code> （两个函数没有区别）来查看每个单元格是否缺失，结合 <code>mean</code> 可以计算出每列缺失值的比例：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df =pd.read_csv(<span class="hljs-string">'data/learn_pandas.csv'</span>,<br>               usecols=[<span class="hljs-string">'Grade'</span>,<span class="hljs-string">'Name'</span>,<span class="hljs-string">'Gender'</span>,<span class="hljs-string">'Height'</span>,<span class="hljs-string">'Weight'</span>,<span class="hljs-string">'Transfer'</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.isna().head()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.isna().mean()<span class="hljs-comment">#查看缺失的比例</span><br></code></pre></td></tr></table></figure><p>如果想要查看某一列缺失或者非缺失的行，可以利用<code>Serires</code>上的<code>isna</code>或者<code>notna</code>进行布尔索引，例如，查看身高缺失的行：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df[df.Height.isna()].head()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sub_set=df[[<span class="hljs-string">'Height'</span>,<span class="hljs-string">'Weight'</span>,<span class="hljs-string">'Transfer'</span>]]<br>df[sub_set.isna().all(axis=<span class="hljs-number">1</span>)]<span class="hljs-comment"># 全部缺失</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df[sub_set.isna().any(<span class="hljs-number">1</span>)].head()<br></code></pre></td></tr></table></figure><h2 id="缺失信息的删除"><a href="#缺失信息的删除" class="headerlink" title="缺失信息的删除"></a>缺失信息的删除</h2><p>数据处理中经常需要根据缺失值的大小、比例或其他特征来进行行样本或列特征的删除，<code>pandas</code>中提供了<code>dropna</code>函数来进行操作。</p><p><code>dropna</code>的主要参数为轴方向<code>axis</code>（默认为0，即删除行），删除方式<code>how</code>，删除的非缺失值格式阈值<code>thresh</code>（非缺失值没有到达这个数量的相应维度会被删除），备选的删除子集<code>subset</code>，其中<code>how</code>主要有<code>any</code>和<code>all</code>两种参数可以选择</p><p>例如，删除身高体重至少有一个缺失的行</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res=df.dropna(how=<span class="hljs-string">'any'</span>,subset=[<span class="hljs-string">'Height'</span>,<span class="hljs-string">'Weight'</span>])<br>res.shape<br></code></pre></td></tr></table></figure><p>例如删除超过15个缺失值的列</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res=df.dropna(axis=<span class="hljs-number">1</span>,thresh=df.shape[<span class="hljs-number">0</span>]<span class="hljs-number">-15</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res.head()<br></code></pre></td></tr></table></figure><p>当然，不用 <code>dropna</code> 同样是可行的，例如上述的两个操作，也可以使用布尔索引来完成：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res=df.loc[df[[<span class="hljs-string">'Height'</span>,<span class="hljs-string">'Weight'</span>]].notna().all(<span class="hljs-number">1</span>)]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res.shape<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res=df.loc[:,~(df.isna().sum()&gt;<span class="hljs-number">15</span>)]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res.head()<br></code></pre></td></tr></table></figure><h2 id="二、缺失值的填充和插值"><a href="#二、缺失值的填充和插值" class="headerlink" title="二、缺失值的填充和插值"></a>二、缺失值的填充和插值</h2><h2 id="1-利用fillna进行填充"><a href="#1-利用fillna进行填充" class="headerlink" title="1. 利用fillna进行填充"></a>1. 利用fillna进行填充</h2><p>在<code>fillna</code>中有三个参数是常用的：<code>value,method,limit</code>其中<code>value</code>为填充值，可以是标量，也可以是索引到元素的字典映射，<code>method</code>为填充方法，有用前面的元素填充<code>ffill</code>和用后面的元素填充<code>bfill</code>两种类型，<code>limit</code>参数表示连续缺失值的最大填充次数</p><p>下面构造一个简单的<code>Series</code>来说明用法</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s=pd.Series([np.nan,<span class="hljs-number">1</span>,np.nan,np.nan,<span class="hljs-number">2</span>,np.nan],<br>           list(<span class="hljs-string">'aaabcd'</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.fillna(method=<span class="hljs-string">'ffill'</span>) <span class="hljs-comment"># 用前面的值填充</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.fillna(method=<span class="hljs-string">'bfill'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.fillna(method=<span class="hljs-string">'ffill'</span>, limit=<span class="hljs-number">1</span>) <span class="hljs-comment"># 连续出现的缺失，最多填充一次</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.fillna(s.mean())<span class="hljs-comment"># 均值填充</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.fillna(&#123;<span class="hljs-string">'a'</span>:<span class="hljs-number">100</span>,<span class="hljs-string">'d'</span>:<span class="hljs-number">200</span>&#125;)<span class="hljs-comment"># 通过索引映射填充的值</span><br></code></pre></td></tr></table></figure><p>有时为了更加合理地填充，需要先进行分组后再操作。例如，根据年级进行身高的均值填充：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.groupby(<span class="hljs-string">'Grade'</span>)[<span class="hljs-string">'Height'</span>].transform(<br>                        <span class="hljs-keyword">lambda</span> x:x.fillna(x.mean())).head()<br></code></pre></td></tr></table></figure><h2 id="练一练"><a href="#练一练" class="headerlink" title="练一练"></a>练一练</h2><p>对一个序列以如下规则填充缺失值：如果单独出现的缺失值，就用前后均值填充，如果连续出现的缺失值就不填充，即序列[1, NaN, 3, NaN, NaN]填充后为[1, 2, 3, NaN, NaN]，请利用 fillna 函数实现。（提示：利用 limit 参数）</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s = pd.Series([<span class="hljs-number">1</span>,np.nan,<span class="hljs-number">3</span>, np.nan, np.nan])<br>s1 = s.fillna(method=<span class="hljs-string">'ffill'</span>,limit=<span class="hljs-number">1</span>)<br>s2 = s.fillna(method=<span class="hljs-string">'bfill'</span>,limit=<span class="hljs-number">1</span>)<br>s = pd.Series(list(map(<span class="hljs-keyword">lambda</span> x,y: (x+y)/<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> np.isnan(x) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> np.isnan(y) <span class="hljs-keyword">else</span> np.nan, s1,s2)))<br>s<br></code></pre></td></tr></table></figure><h2 id="2-插值函数"><a href="#2-插值函数" class="headerlink" title="2.插值函数"></a>2.插值函数</h2><p>在关于 <code>interpolate</code> 函数的 文档 描述中，列举了许多插值法，包括了大量 <code>Scipy</code> 中的方法。由于很多插值方法涉及到比较复杂的数学知识，因此这里只讨论比较常用且简单的三类情况，即线性插值、最近邻插值和索引插值。</p><p>对于 <code>interpolate</code> 而言，除了插值方法（默认为 <code>linear</code> 线性插值）之外，有与 <code>fillna</code> 类似的两个常用参数，一个是控制方向的 <code>limit_direction</code> ，另一个是控制最大连续缺失值插值个数的 <code>limit</code> 。其中，限制插值的方向默认为 <code>forward</code> ，这与 <code>fillna</code> 的 <code>method </code>中的 <code>ffill</code> 是类似的，若想要后向限制插值或者双向限制插值可以指定为 <code>backward</code> 或 <code>both</code> 。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s = pd.Series([np.nan, np.nan, <span class="hljs-number">1</span>,<br>  ....:                np.nan, np.nan, np.nan,<br>  ....:                <span class="hljs-number">2</span>, np.nan, np.nan])<br>  ....:<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.values<br></code></pre></td></tr></table></figure><p>例如，在默认线性插值法下分别进行 <code>backward</code> 和双向限制插值，同时限制最大连续条数为1：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res=s.interpolate(limit_direction=<span class="hljs-string">'backward'</span>,limit=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res.values<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res=s.interpolate(limit_direction=<span class="hljs-string">'both'</span>,limit=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res.values<br></code></pre></td></tr></table></figure><p>第二种常见的插值是最近邻插补，即缺失值的元素和离它最近的非缺失值元素一样：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.interpolate(<span class="hljs-string">'nearest'</span>).values<br></code></pre></td></tr></table></figure><p>最后来介绍索引插值，即根据索引大小进行线性插值。例如，构造不等间距的索引进行演示：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s=pd.Series([<span class="hljs-number">0</span>,np.nan,<span class="hljs-number">10</span>],index=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.interpolate()<span class="hljs-comment">#默认的线性插值，等价于计算中点的值</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.interpolate(method=<span class="hljs-string">'index'</span>)<span class="hljs-comment">#和索引有关的线性插值，计算相应的索引对应的值</span><br></code></pre></td></tr></table></figure><p>同时，这种方法对于时间戳索引也是可以使用的，有关时间序列的其他话题会在第十章进行讨论，这里举一个简单的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s=pd.Series([<span class="hljs-number">0</span>,np.nan,<span class="hljs-number">10</span>],<br>           index=pd.to_datetime([<span class="hljs-string">'20200101'</span>,<br>                                <span class="hljs-string">'20200102'</span>,<br>                                <span class="hljs-string">'20200111'</span>]))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.interpolate()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.interpolate(method=<span class="hljs-string">'index'</span>)<br></code></pre></td></tr></table></figure><h2 id="关于polynomial和spline插值的注意事项"><a href="#关于polynomial和spline插值的注意事项" class="headerlink" title="关于polynomial和spline插值的注意事项"></a>关于polynomial和spline插值的注意事项</h2><p>在 <code>interpolate</code> 中如果选用 <code>polynomial</code> 的插值方法，它内部调用的是 <code>scipy.interpolate.interp1d(*,*,kind=order)</code> ，这个函数内部调用的是 <code>make_interp_spline</code> 方法，因此其实是样条插值而不是类似于<code> numpy</code> 中的 <code>polyfit</code> 多项式拟合插值；而当选用 <code>spline</code> 方法时， <code>pandas </code>调用的是 <code>scipy.interpolate.UnivariateSpline</code> 而不是普通的样条插值。这一部分的文档描述比较混乱，而且这种参数的设计也是不合理的，当使用这两类插值方法时，用户一定要小心谨慎地根据自己的实际需求选取恰当的插值方法。</p><h2 id="Nullable类型"><a href="#Nullable类型" class="headerlink" title="Nullable类型"></a>Nullable类型</h2><h2 id="1-缺失记号及其缺陷"><a href="#1-缺失记号及其缺陷" class="headerlink" title="1. 缺失记号及其缺陷"></a>1. 缺失记号及其缺陷</h2><p>在 <code>python</code> 中的缺失值用 <code>None</code> 表示，该元素除了等于自己本身之外，与其他任何元素不相等：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-literal">None</span>==<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-literal">None</span>==<span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-literal">None</span>==[]<br></code></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-literal">None</span>==<span class="hljs-string">''</span><br></code></pre></td></tr></table></figure><pre><code>False</code></pre><p>在<code> numpy</code> 中利用 <code>np.nan</code> 来表示缺失值，该元素除了不和其他任何元素相等之外，和自身的比较结果也返回<code> False</code> ：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nan==np.nan<br></code></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nan==<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nan==<span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><pre><code>False</code></pre><p>值得注意的是，虽然在对缺失序列或表格的元素进行比较操作的时候， <code>np.nan</code> 的对应位置会返回 <code>False</code><br><strong>但是在使用 <code>equals</code> 函数进行两张表或两个序列的相同性检验时，会自动跳过两侧表都是缺失值的位置，直接返回 <code>True</code> :</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s1=pd.Series([<span class="hljs-number">1</span>,np.nan])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s2=pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s3=pd.Series([<span class="hljs-number">1</span>,np.nan])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s1==<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><pre><code>0     True1    Falsedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s1.equals(s2)<br></code></pre></td></tr></table></figure><pre><code>False</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s1.equals(s3)<br></code></pre></td></tr></table></figure><pre><code>True</code></pre><p>在<strong>时间序列的对象</strong>中， <code>pandas</code> 利用 <code>pd.NaT</code> 来指代缺失值，它的作用和 <code>np.nan</code> 是一致的（时间序列的对象和构造将在第十章讨论）：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.to_timedelta([<span class="hljs-string">'30s'</span>,np.nan])<span class="hljs-comment">#Timedelta 中的NaT</span><br></code></pre></td></tr></table></figure><pre><code>TimedeltaIndex([&#39;0 days 00:00:30&#39;, NaT], dtype=&#39;timedelta64[ns]&#39;, freq=None)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.to_datetime([<span class="hljs-string">'20200101'</span>,np.nan])<span class="hljs-comment">#Datetime中的NaT</span><br></code></pre></td></tr></table></figure><pre><code>DatetimeIndex([&#39;2020-01-01&#39;, &#39;NaT&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</code></pre><p>那么为什么要引入 <code>pd.NaT</code> 来表示时间对象中的缺失呢？仍然以 <code>np.nan</code> 的形式存放会有什么问题？在 <code>pandas</code> 中可以看到 <code>object</code> 类型的对象，而 <code>object</code> 是一种混杂对象类型，如果出现了多个类型的元素同时存储在 <code>Series</code> 中，它的类型就会变成 <code>object</code> 。例如，同时存放整数和字符串的列表：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([<span class="hljs-number">1</span>,<span class="hljs-string">'two'</span>])<br></code></pre></td></tr></table></figure><pre><code>0      11    twodtype: object</code></pre><p><strong><code>NaT</code> 问题的根源来自于 <code>np.nan</code> 的本身是一种浮点类型</strong>，而如果浮点和时间类型混合存储，如果不设计新的内置缺失类型来处理，就会变成含糊不清的 <code>object </code>类型，这显然是不希望看到的</p><p><strong>同时，由于 np.nan 的浮点性质，如果在一个整数的 Series 中出现缺失，那么其类型会转变为 float64 ；</strong>  </p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([<span class="hljs-number">1</span>,np.nan]).dtype<br></code></pre></td></tr></table></figure><pre><code>dtype(&#39;float64&#39;)</code></pre><p><strong>而如果在一个布尔类型的序列中出现缺失，那么其类型就会转为 object 而不是 bool ：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,np.nan]).dtype<br></code></pre></td></tr></table></figure><pre><code>dtype(&#39;O&#39;)</code></pre><p>因此，在进入 <code>1.0.0 </code>版本后， <code>pandas</code> 尝试设计了一种新的缺失类型 <code>pd.NA</code> 以及三种 <code>Nullable</code> 序列类型来应对这些缺陷，它们分别是 <code>Int, boolean</code> 和 <code>string</code> 。</p><h2 id="2-Nullable类型的性质"><a href="#2-Nullable类型的性质" class="headerlink" title="2. Nullable类型的性质"></a>2. Nullable类型的性质</h2><p>从字面意义上看 <code>Nullable</code> 就是可空的，言下之意就是序列类型不受缺失值的影响。例如，在上述三个 <code>Nullable</code> 类型中存储缺失值，都会转为 <code>pandas</code> 内置的 <code>pd.NA</code> ：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([np.nan,<span class="hljs-number">1</span>],dtype=<span class="hljs-string">'Int64'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([np.nan,<span class="hljs-literal">True</span>],dtype=<span class="hljs-string">'boolean'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([np.nan,<span class="hljs-string">'my_str'</span>],dtype=<span class="hljs-string">'string'</span>)<br></code></pre></td></tr></table></figure><p>在 <code>Int</code> 的序列中，返回的结果会尽可能地成为 <code>Nullable</code> 的类型：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([np.nan,<span class="hljs-number">0</span>],dtype=<span class="hljs-string">'Int64'</span>)+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([np.nan,<span class="hljs-number">0</span>],dtype=<span class="hljs-string">'Int64'</span>)==<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.Series([np.nan,<span class="hljs-number">0</span>],dtype=<span class="hljs-string">'Int64'</span>)*<span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure><p>对于<code>boolean</code>类型的序列而言，其和 <code>bool</code> 序列的行为主要有两点区别：</p><p><strong>第一点是带有缺失的布尔列表无法进行索引器中的选择，而 <code>boolean</code> 会把缺失值看作 <code>False</code> ：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s=pd.Series([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s_bool=pd.Series([<span class="hljs-literal">True</span>,np.nan])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s_boolean=pd.Series([<span class="hljs-literal">True</span>,np.nan]).astype(<span class="hljs-string">'boolean'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s[s_bool] <span class="hljs-comment">#报错</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s[s_boolean]<br></code></pre></td></tr></table></figure><p><strong>第二点是在进行逻辑运算时， bool 类型在缺失处返回的永远是 False ，而 boolean 会根据逻辑运算是否能确定唯一结果来返回相应的值。</strong><br>那什么叫能否确定唯一结果呢？<br>举个简单例子：   </p><ul><li>True | pd.NA 中无论缺失值为什么值，必然返回 True </li><li>False | pd.NA 中的结果会根据缺失值取值的不同而变化，此时返回 pd.NA  </li><li>False &amp; pd.NA 中无论缺失值为什么值，必然返回 False 。 </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s_boolean &amp; <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s_boolean | <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">~s_boolean<span class="hljs-comment"># 取反操作同样是无法唯一地判断缺失结果</span><br></code></pre></td></tr></table></figure><p>关于 <code>string</code> 类型的具体性质将在下一章文本数据中进行讨论。<br>一般在实际数据处理时，可以在数据集读入后，先通过 <code>convert_dtypes</code> 转为 <code>Nullable</code> 类型：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">'data/learn_pandas.csv'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df=df.convert_dtypes()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.dtypes<br></code></pre></td></tr></table></figure><h2 id="3-缺失数据的计算和分组"><a href="#3-缺失数据的计算和分组" class="headerlink" title="3. 缺失数据的计算和分组"></a>3. 缺失数据的计算和分组</h2><p>当调用函数<code>sum,prod</code>使用加法和乘法的时候，缺失数据等价于被分别视作0和1，即不改变原来的计算结果</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s=pd.Series([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,np.nan,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.sum(),s.prod()<br></code></pre></td></tr></table></figure><p>当使用累计函数的时候，会自动跳过缺失值所处的位置</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.cumsum()<br></code></pre></td></tr></table></figure><p>当进行单个标量运算的时候，除了 <code>np.nan ** 0 </code>和 <code>1 ** np.nan</code> 这两种情况为确定的值之外，所有运算结果全为缺失（ <code>pd.NA</code> 的行为与此一致 ），并且 <code>np.nan</code> 在比较操作时一定返回 <code>False</code> ，而 <code>pd.NA</code> 返回 <code>pd.NA</code> </p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nan==<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.NA==<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nan&gt;<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.NA&gt;<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nan+<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.log(np.nan)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.add(np.nan,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nan**<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.NA**<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>**np.nan<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>**pd.NA<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.diff()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">s.pct_change()<br></code></pre></td></tr></table></figure><p>对于一些函数而言，<strong>缺失可以作为一个类别处理</strong>，例如在 <code>groupby, get_dummies</code> 中可以设置相应的参数来进行增加缺失类别:</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df_nan=pd.DataFrame(&#123;<span class="hljs-string">'category'</span>:[<span class="hljs-string">'a'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,np.nan,np.nan],<br>                    <span class="hljs-string">'value'</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df_nan<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df_nan.groupby(<span class="hljs-string">'category'</span>,dropna=<span class="hljs-literal">False</span>)[<span class="hljs-string">'value'</span>].mean()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">pd.get_dummies(df_nan.category,dummy_na=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="Ex1：缺失值与类别的相关性检验"><a href="#Ex1：缺失值与类别的相关性检验" class="headerlink" title="Ex1：缺失值与类别的相关性检验"></a>Ex1：缺失值与类别的相关性检验</h2><p><strong>在数据处理中，含有过多缺失值的列往往会被删除，除非缺失情况与标签强相关。</strong>下面有一份关于二分类问题的数据集，其中 X_1, X_2 为特征变量， y 为二分类标签</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df=pd.read_csv(<span class="hljs-string">'data/missing_chi.csv'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.head()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.isna().mean()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.y.value_counts(normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>事实上，有时缺失值出现或者不出现本身就是一种特征，并且在一些场合下可能与标签的正负是相关的。<strong>关于缺失出现与否和标签的正负性</strong>，在统计学中可以利用<strong>卡方检验</strong>来断言它们是否存在相关性。  </p><p>按照<strong>特征缺失的正例、特征缺失的负例、特征不缺失的正例、特征不缺失的负例，可以分为四种情况</strong>，设它们分别对应的样例数为 <code>n11,n10,n01,n00</code> 。</p><p>假若它们是不相关的，那么特征缺失中正例的理论值，就应该接近于特征缺失总数 × 总体正例的比例，即：</p><p>$$ E_{11} = n_{11} \approx (n_{11}+n_{10}) \times \frac{n_{11}+n_{01}}{n_{11}+n_{10}+n_{01}+n_{00}} = F_{11}$$</p><p>其他的三种情况同理，现将实际值和理论值分别记作$E_{ij},F_{ij}$,那么希望下面的统计量越小越好，即代表实际值接近不相关情况的理论值：</p><p>$$S = \sum_{i \in { 0,1} } \sum_{ j \in {0,1}} \frac{(E_{ij} - F_{ij})^2}{F_{ij}} $$</p><p>可以证明上面的统计量近似服从自由度为 1 的卡方分布，即$S\overset{\cdot}{\sim} \chi^2(1) $因此，可通过计算 $P(\chi^2(1)&gt;S)$的概率来进行相关性的判别，一般认为当此概率小于 0.05 时缺失情况与标签正负存在相关关系，即不相关条件下的理论值与实际值相差较大。</p><p>上面所说的概率即为统计学上关于 $2\times 2 $列联表检验问题的 p 值， 它可以通过 <code>scipy.stats.chi2.sf(S, 1)</code> 得到。请根据上面的材料，分别对 X_1, X_2 列进行检验。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df=pd.read_csv(<span class="hljs-string">'data/missing_chi.csv'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cat_1 = df.X_1.fillna(<span class="hljs-string">'NaN'</span>).mask(df.X_1.notna()).fillna(<span class="hljs-string">"NotNaN"</span>)<br>cat_2 = df.X_2.fillna(<span class="hljs-string">'NaN'</span>).mask(df.X_2.notna()).fillna(<span class="hljs-string">"NotNaN"</span>)<br></code></pre></td></tr></table></figure><p>交叉表(crossTab)<br>交叉表是用于<strong>统计分组频率</strong>的特殊透视表</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df_1 = pd.crosstab(cat_1, df.y, margins=<span class="hljs-literal">True</span>)<br>df_2 = pd.crosstab(cat_2, df.y, margins=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_S</span><span class="hljs-params">(my_df)</span>:</span><br>    S = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>            E = my_df.iat[i, j]<br>            F = my_df.iat[i, <span class="hljs-number">2</span>]*my_df.iat[<span class="hljs-number">2</span>, j]/my_df.iat[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>            S.append((E-F)**<span class="hljs-number">2</span>/F)<br>    <span class="hljs-keyword">return</span> sum(S)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res1 = compute_S(df_1)<br>res2 = compute_S(df_2)<br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> chi2<br>chi2.sf(res1, <span class="hljs-number">1</span>) <span class="hljs-comment"># X_1检验的p值 # 不能认为相关，剔除</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">chi2.sf(res2,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="Ex2：用回归模型解决分类问题"><a href="#Ex2：用回归模型解决分类问题" class="headerlink" title="Ex2：用回归模型解决分类问题"></a>Ex2：用回归模型解决分类问题</h2><p><code>KNN</code> 是一种监督式学习模型，既可以解决回归问题，又可以解决分类问题。对于分类变量，利用 <code>KNN</code> 分类模型可以实现其缺失值的插补，思路是度量缺失样本的特征与所有其他样本特征的距离，当给定了模型参数 <code>n_neighbors=n</code> 时，计算离该样本距离最近的 <code>n </code>个样本点中最多的那个类别，并把这个类别作为该样本的缺失预测类别，具体如下图所示，未知的类别被预测为黄色：</p><p><img src="http://inter.joyfulpandas.datawhale.club/_images/ch7_ex.png" alt="img"></p><p>上面有色点的特征数据提供如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df=pd.read_excel(<span class="hljs-string">'data/color.xlsx'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df.head(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>已知待预测的样本点为 $X_1=0.8,X_2=−0.2$ ，那么预测类别可以如下写出</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">clf=KNeighborsClassifier(n_neighbors=<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">clf.fit(df.iloc[:,:<span class="hljs-number">2</span>],df.Color)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">clf.predict([[<span class="hljs-number">0.8</span>,<span class="hljs-number">-0.2</span>]])<br></code></pre></td></tr></table></figure><p>1.对于回归问题而言，需要得到的是一个具体的数值，因此预测值由最近的 n 个样本对应的平均值获得。请把上面的这个分类问题转化为回归问题，仅使用 KNeighborsRegressor 来完成上述的 KNeighborsClassifier 功能。</p><h2 id="标准答案"><a href="#标准答案" class="headerlink" title="标准答案"></a>标准答案</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br>df = pd.read_excel(<span class="hljs-string">'../data/color.xlsx'</span>)<br>df_dummies = pd.get_dummies(df.Color)<br>stack_list = []<br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> df_dummies.columns:<br>    clf = KNeighborsRegressor(n_neighbors=<span class="hljs-number">6</span>)<br>    clf.fit(df.iloc[:,:<span class="hljs-number">2</span>], df_dummies[col])<br>    res = clf.predict([[<span class="hljs-number">0.8</span>, <span class="hljs-number">-0.2</span>]]).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)<br>    stack_list.append(res)<br>code_res = pd.Series(np.hstack(stack_list).argmax(<span class="hljs-number">1</span>))<br>df_dummies.columns[code_res[<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br>df=pd.read_excel(<span class="hljs-string">'data/color.xlsx'</span>)<br>df_dummies=pd.get_dummies(df.Color)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df_dummies.head()<span class="hljs-comment">#转换成one-hot编码模式</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">stack_list = []<br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> df_dummies.columns:<br>    print(col)<br>    clf = KNeighborsRegressor(n_neighbors=<span class="hljs-number">6</span>)<br>    clf.fit(df.iloc[:,:<span class="hljs-number">2</span>], df_dummies[col])<br>    res = clf.predict([[<span class="hljs-number">0.8</span>, <span class="hljs-number">-0.2</span>]]).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)<br>    print(res)<br>    stack_list.append(res)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.hstack(stack_list).argmax(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">code_res = pd.Series(np.hstack(stack_list).argmax(<span class="hljs-number">1</span>))<br>df_dummies.columns[code_res[<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><p>2.请根据第1问中的方法，对 <code>audit </code>数据集中的 <code>Employment</code> 变量进行缺失值插补。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">'data/audit.csv'</span>)<br>pd.get_dummies(df[[<span class="hljs-string">'Marital'</span>, <span class="hljs-string">'Gender'</span>]])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsRegressor<br>df = pd.read_csv(<span class="hljs-string">'data/audit.csv'</span>)<br>res_df = df.copy()<br>res_df2 = df.copy()<br><span class="hljs-comment">#数据处理加归一化这句写的很妙</span><br>df = pd.concat([pd.get_dummies(df[[<span class="hljs-string">'Marital'</span>, <span class="hljs-string">'Gender'</span>]]), df[[<span class="hljs-string">'Age'</span>,<span class="hljs-string">'Income'</span>,<span class="hljs-string">'Hours'</span>]].apply(<span class="hljs-keyword">lambda</span> x:(x-x.min())/(x.max()-x.min())), df.Employment],<span class="hljs-number">1</span>)<br>df.head()<br></code></pre></td></tr></table></figure><h2 id="使用KNN分类法"><a href="#使用KNN分类法" class="headerlink" title="使用KNN分类法"></a>使用KNN分类法</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>clf=KNeighborsClassifier(n_neighbors=<span class="hljs-number">6</span>)<br>train=df[df.Employment.notna()]<br>test=df[df.Employment.isna()]<br>clf.fit(train.iloc[:,:<span class="hljs-number">-1</span>],train.Employment)<br>predict=clf.predict(test.iloc[:,:<span class="hljs-number">-1</span>])<br>res_df2.loc[res_df.Employment.isna(), <span class="hljs-string">'Employment'</span>] = predict<br>res_df2.isna().sum()<br></code></pre></td></tr></table></figure><h2 id="使用KNN分类树"><a href="#使用KNN分类树" class="headerlink" title="使用KNN分类树"></a>使用KNN分类树</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">X_train = df[df.Employment.notna()]<br>X_test = df[df.Employment.isna()]<br>df_dummies = pd.get_dummies(X_train.Employment)<br>stack_list = []<br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> df_dummies.columns:<br>    clf = KNeighborsRegressor(n_neighbors=<span class="hljs-number">6</span>)<br>    clf.fit(X_train.iloc[:,:<span class="hljs-number">-1</span>], df_dummies[col])<br>    res = clf.predict(X_test.iloc[:,:<span class="hljs-number">-1</span>]).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)<br>    stack_list.append(res)<br>code_res = pd.Series(np.hstack(stack_list).argmax(<span class="hljs-number">1</span>))<br>cat_res = code_res.replace(dict(zip(list(range(df_dummies.shape[<span class="hljs-number">0</span>])),df_dummies.columns)))<br>res_df.loc[res_df.Employment.isna(), <span class="hljs-string">'Employment'</span>] = cat_res.values<br>res_df.isna().sum()<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;缺失数据&quot;&gt;&lt;a href=&quot;#缺失数据&quot; class=&quot;headerlink&quot; title=&quot;缺失数据&quot;&gt;&lt;/a&gt;缺失数据&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; np&lt;br&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; pd&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;一、缺失值的统计和删除&quot;&gt;&lt;a href=&quot;#一、缺失值的统计和删除&quot; class=&quot;headerlink&quot; title=&quot;一、缺失值的统计和删除&quot;&gt;&lt;/a&gt;一、缺失值的统计和删除&lt;/h2&gt;&lt;h2 id=&quot;1-缺失信息的统计&quot;&gt;&lt;a href=&quot;#1-缺失信息的统计&quot; class=&quot;headerlink&quot; title=&quot;1. 缺失信息的统计&quot;&gt;&lt;/a&gt;1. 缺失信息的统计&lt;/h2&gt;&lt;p&gt;缺失数据可以使用 &lt;code&gt;isna&lt;/code&gt; 或 &lt;code&gt;isnull&lt;/code&gt; （两个函数没有区别）来查看每个单元格是否缺失，结合 &lt;code&gt;mean&lt;/code&gt; 可以计算出每列缺失值的比例：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="pandas" scheme="https://yoursite.com/tags/pandas/"/>
    
      <category term="datawhale" scheme="https://yoursite.com/tags/datawhale/"/>
    
  </entry>
  
  <entry>
    <title>datawhale-pandas数据分析预备</title>
    <link href="https://yoursite.com/2020/12/21/datawhale-pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A2%84%E5%A4%87/"/>
    <id>https://yoursite.com/2020/12/21/datawhale-pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%A2%84%E5%A4%87/</id>
    <published>2020-12-21T04:40:31.000Z</published>
    <updated>2021-02-20T13:45:38.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="datawhale-pandas数据分析预备"><a href="#datawhale-pandas数据分析预备" class="headerlink" title="datawhale-pandas数据分析预备"></a>datawhale-pandas数据分析预备</h2><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_func</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x<br></code></pre></td></tr></table></figure><h2 id="for-i-in"><a href="#for-i-in" class="headerlink" title="[* for i in *]"></a>[* for i in *]</h2><p>其中，第一个 * 为映射函数，其输入为后面 i 指代的内容，第二个 * 表示迭代的对象。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">[my_func(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<br></code></pre></td></tr></table></figure><p>out:[0, 2, 4, 6, 8]</p><p>列表表达式支持多层嵌套</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">[m+<span class="hljs-string">'_'</span>+n <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span>[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span>[<span class="hljs-string">'c'</span>,<span class="hljs-string">'d'</span>]]<br></code></pre></td></tr></table></figure><p>out:[‘a_c’, ‘a_d’, ‘b_c’, ‘b_d’]</p><h2 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h2><h2 id="value-a-if-condition-else-b-："><a href="#value-a-if-condition-else-b-：" class="headerlink" title="value = a if condition else b ："></a>value = a if condition else b ：</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">value = <span class="hljs-string">'cat'</span> <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'dog'</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">value<br></code></pre></td></tr></table></figure><p>out:’cat’</p><p>下面举一个例子，截断列表中超过5的元素，即超过5的用5代替，小于5的保留原来的值：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">L=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><br>[i <span class="hljs-keyword">if</span> i&lt;=<span class="hljs-number">5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">5</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> L]<br></code></pre></td></tr></table></figure><p>out:[1, 2, 3, 4, 5, 5, 5]</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">my_func=<span class="hljs-keyword">lambda</span> x:<span class="hljs-number">2</span>*x<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">my_func(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>out:4</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f2=<span class="hljs-keyword">lambda</span> a,b:a+b<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f2(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>out:3</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">[ (<span class="hljs-keyword">lambda</span> i:<span class="hljs-number">2</span>*i)(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]<br></code></pre></td></tr></table></figure><p>out:[0, 2, 4, 6, 8]</p><p>对于上述的这种列表推导式的匿名函数映射， Python 中提供了 map 函数来完成，它返回的是一个 map 对象，需要通过 list 转为列表：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list(map(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span>*x, range(<span class="hljs-number">5</span>)))<br></code></pre></td></tr></table></figure><p>[0, 2, 4, 6, 8]</p><p>对于多个输入值的函数映射，可以通过追加迭代对象实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list(map(<span class="hljs-keyword">lambda</span> x, y: str(x)+<span class="hljs-string">'_'</span>+y, range(<span class="hljs-number">5</span>), list(<span class="hljs-string">'abcde'</span>)))<br></code></pre></td></tr></table></figure><p> [‘0_a’, ‘1_b’, ‘2_c’, ‘3_d’, ‘4_e’]</p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>zip函数能够把多个可迭代对象打包成一个元组构成的可迭代对象，它返回了一个 zip 对象，通过 tuple, list 可以得到相应的打包结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">L1, L2, L3 = list(<span class="hljs-string">'abc'</span>), list(<span class="hljs-string">'def'</span>), list(<span class="hljs-string">'hij'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list(zip(L1, L2, L3))<br></code></pre></td></tr></table></figure><p>[(‘a’, ‘d’, ‘h’), (‘b’, ‘e’, ‘i’), (‘c’, ‘f’, ‘j’)]</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">tuple(zip(L1, L2, L3))<br></code></pre></td></tr></table></figure><p>((‘a’, ‘d’, ‘h’), (‘b’, ‘e’, ‘i’), (‘c’, ‘f’, ‘j’))</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i,j,k <span class="hljs-keyword">in</span> zip(L1,L2,L3):<br>    print(i,j,k)<br></code></pre></td></tr></table></figure><p>a d h<br>b e i<br>c f j</p><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><p><code>enumerate</code> 是一种特殊的打包，它可以在迭代时绑定迭代元素的遍历序号：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">L = list(<span class="hljs-string">'abcd'</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> enumerate(L):<br>    print(index, value)<br></code></pre></td></tr></table></figure><p>0 a<br>1 b<br>2 c<br>3 d</p><p>用zip实现这个功能</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">[*zip(range(len(L)),L)]<br></code></pre></td></tr></table></figure><p>[(0, ‘a’), (1, ‘b’), (2, ‘c’), (3, ‘d’)]</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> index,value <span class="hljs-keyword">in</span> zip(range(len(L)),L):<br>    print(index,value)<br></code></pre></td></tr></table></figure><p>0 a<br>1 b<br>2 c<br>3 d</p><p>当需要对两个列表建立字典映射时，可以利用 zip 对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dict(zip(L1,L2))<br></code></pre></td></tr></table></figure><p>{‘a’: ‘d’, ‘b’: ‘e’, ‘c’: ‘f’}</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">zipped = list(zip(L1, L2, L3))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">zipped<br></code></pre></td></tr></table></figure><p>[(‘a’, ‘d’, ‘h’), (‘b’, ‘e’, ‘i’), (‘c’, ‘f’, ‘j’)]</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">list(zip(*zipped))<br></code></pre></td></tr></table></figure><p>[(‘a’, ‘b’, ‘c’), (‘d’, ‘e’, ‘f’), (‘h’, ‘i’, ‘j’)]</p><h2 id="numpy回顾"><a href="#numpy回顾" class="headerlink" title="numpy回顾"></a>numpy回顾</h2><h2 id="1-np数组的构造"><a href="#1-np数组的构造" class="headerlink" title="1. np数组的构造"></a>1. np数组的构造</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><p>最一般的方法是通过 array 来构造：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>array([1, 2, 3])</p><p>等差序列： <code>np.linspace</code>, <code>np.arange</code></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>) <span class="hljs-comment"># 起始、终止（包含）、样本个数</span><br></code></pre></td></tr></table></figure><p>array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5, 5. ])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 起始、终止（不包含）、步长</span><br></code></pre></td></tr></table></figure><p>array([1, 3])</p><p>特殊矩阵： <code>zeros</code>, <code>eye</code>, <code>full</code></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 传入元组表示各维度大小</span><br></code></pre></td></tr></table></figure><p>array([[0., 0., 0.],<br>      [0., 0., 0.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.eye(<span class="hljs-number">3</span>) <span class="hljs-comment">#代表维度3*3的单位矩阵</span><br></code></pre></td></tr></table></figure><p>array([[1., 0., 0.],<br>        [0., 1., 0.],<br>        [0., 0., 1.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.eye(<span class="hljs-number">3</span>, k=<span class="hljs-number">1</span>) <span class="hljs-comment"># 偏移主对角线1个单位的伪单位矩阵</span><br></code></pre></td></tr></table></figure><p>array([[0., 1., 0.],<br>        [0., 0., 1.],<br>        [0., 0., 0.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.eye(<span class="hljs-number">3</span>, k=<span class="hljs-number">-1</span>) <span class="hljs-comment"># 偏移主对角线1个单位的伪单位矩阵</span><br></code></pre></td></tr></table></figure><p>array([[0., 0., 0.],<br>        [1., 0., 0.],<br>        [0., 1., 0.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.eye(<span class="hljs-number">3</span>, k=<span class="hljs-number">2</span>) <span class="hljs-comment"># 偏移主对角线1个单位的伪单位矩阵</span><br></code></pre></td></tr></table></figure><p>array([[0., 0., 1.],<br>        [0., 0., 0.],<br>        [0., 0., 0.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.full((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">10</span>)<span class="hljs-comment"># 元组传入大小，10表示填充数值</span><br></code></pre></td></tr></table></figure><p>array([[10, 10, 10],<br>        [10, 10, 10]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.full((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment"># 每行填入相同的列表</span><br></code></pre></td></tr></table></figure><p>array([[1, 2, 3],<br>        [1, 2, 3]])</p><p>随机矩阵: <code>np.random</code></p><table><thead><tr><th>函数</th><th>含义</th></tr></thead><tbody><tr><td><code>np.random.rand</code></td><td>0-1均匀分布的随机数组</td></tr><tr><td><code>np.random.randn</code></td><td>标准正态的随机数组</td></tr><tr><td><code>np.random.randint</code></td><td>随机整数组</td></tr><tr><td><code>np.random.choice</code></td><td>随机列表抽样</td></tr></tbody></table><h2 id="np-random-rand"><a href="#np-random-rand" class="headerlink" title="np.random.rand"></a><code>np.random.rand</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.rand(<span class="hljs-number">3</span>)<span class="hljs-comment"># 生成服从0-1均匀分布的三个随机数</span><br></code></pre></td></tr></table></figure><p>array([0.25659368, 0.37802498, 0.62494881])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.rand(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<span class="hljs-comment"># 生成服从0-1均匀分布的三个随机数</span><br></code></pre></td></tr></table></figure><p>array([[0.64676496, 0.59502481, 0.61343668],<br>        [0.16019992, 0.49285208, 0.96761024],<br>        [0.94030055, 0.48943744, 0.1143115 ]])</p><p>对于服从区间 a 到 b 上的均匀分布可以如下生成：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a, b = <span class="hljs-number">5</span>, <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">(b - a) * np.random.rand(<span class="hljs-number">3</span>) + a<br></code></pre></td></tr></table></figure><p>array([ 8.84499261, 10.21774591,  8.16028516])</p><p><strong>一般的，可以选择已有的库函数：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>array([8.86348101, 9.14266299, 8.60513876])</p><h2 id="np-random-randn"><a href="#np-random-randn" class="headerlink" title="np.random.randn"></a><code>np.random.randn</code></h2><p><code>randn</code> 生成了 $N(0,I)$ 的标准正态分布：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.randn(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>array([ 1.41288442, -0.73967664, -0.23529916])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.randn(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>array([[ 0.85735525, -0.17674214],<br>        [-0.28607067,  1.49904315]])</p><p>对于服从$N(\mu, \sigma^2)$的一元正态分布则有</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">mu,sigma=<span class="hljs-number">3</span>,<span class="hljs-number">2.5</span><br>mu+np.random.randn(<span class="hljs-number">3</span>)*sigma<br></code></pre></td></tr></table></figure><p>array([-0.26367497,  1.87383756,  2.81701976])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.normal(<span class="hljs-number">3</span>,<span class="hljs-number">2.5</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>array([6.40062933, 3.28135583, 0.65048172])</p><p><code>randint</code> 可以指定生成<strong>随机整数</strong>最大值（不包含）和维度大小：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">low, high, size = <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 生成5到14的随机整数</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.randint(low, high, size)<br></code></pre></td></tr></table></figure><p>array([[13, 14],<br>        [ 7, 10]])</p><p><code>choice</code> 可以从给定的列表中，以一定概率和方式抽取结果，当不指定概率时为均匀采样，默认抽取方式为有放回抽样：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">my_list = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.choice(my_list, <span class="hljs-number">2</span>, replace=<span class="hljs-literal">False</span>, p=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.1</span> ,<span class="hljs-number">0.1</span>])<br></code></pre></td></tr></table></figure><p>array([‘a’, ‘b’], dtype=’&lt;U1’)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.choice(my_list, (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), replace=<span class="hljs-literal">True</span>, p=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.1</span> ,<span class="hljs-number">0.1</span>])<br></code></pre></td></tr></table></figure><p>array([[‘d’, ‘b’],<br>        [‘b’, ‘b’]], dtype=’&lt;U1’)</p><p><img src="https://img-blog.csdnimg.cn/20201221120439843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-tyytLsj8-1608522933090)(attachment:image.png)]"></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.choice(my_list, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>array([[‘d’, ‘c’, ‘c’],<br>        [‘d’, ‘a’, ‘c’],<br>        [‘d’, ‘b’, ‘b’]], dtype=’&lt;U1’)</p><p>当返回的元素个数与原列表相同时，不放回抽样等价于使用 <code>permutation</code> 函数，即打散原列表：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.permutation(my_list)<br></code></pre></td></tr></table></figure><p>array([‘d’, ‘b’, ‘c’, ‘a’], dtype=’&lt;U1’)</p><p>最后，需要提到的是随机种子，它能够固定随机数的输出结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.rand()<br></code></pre></td></tr></table></figure><p>0.5488135039273248</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.rand(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.rand()<br></code></pre></td></tr></table></figure><p>0.5488135039273248</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.rand()<br></code></pre></td></tr></table></figure><p>0.6027633760716439</p><h2 id="2-np数组的变形与合并"><a href="#2-np数组的变形与合并" class="headerlink" title="2. np数组的变形与合并"></a>2. np数组的变形与合并</h2><p>转置</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)).T<br></code></pre></td></tr></table></figure><p>array([[0., 0.],<br>        [0., 0.],<br>        [0., 0.]])</p><p>合并操作</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.r_[np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))] <span class="hljs-comment">#上下合并</span><br></code></pre></td></tr></table></figure><p>array([[0., 0., 0.],<br>        [0., 0., 0.],<br>        [0., 0., 0.],<br>        [0., 0., 0.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.c_[np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))] <span class="hljs-comment">#左右合并</span><br></code></pre></td></tr></table></figure><p>array([[0., 0., 0., 0., 0., 0.],<br>        [0., 0., 0., 0., 0., 0.]])</p><p>一维数组和二维数组进行合并时，应当把其视作列向量，在长度匹配的情况下只能够使用左右合并的 c_ 操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    np.r_[np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))]<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    Err_Msg=e<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">Err_Msg<br></code></pre></td></tr></table></figure><p>ValueError(‘all the input arrays must have same number of dimensions, but the array at index 0 has 1 dimension(s) and the array at index 1 has 2 dimension(s)’)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.r_[np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros(<span class="hljs-number">2</span>)]<br></code></pre></td></tr></table></figure><p>array([0., 0., 0., 0.])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.c_[np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))]<br></code></pre></td></tr></table></figure><p>array([[0., 0., 0., 0.],<br>         [0., 0., 0., 0.]])</p><p>维度变换: <code>reshape</code></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target = np.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target<br></code></pre></td></tr></table></figure><p>array([[0, 1, 2, 3],<br>           [4, 5, 6, 7]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), order=<span class="hljs-string">'C'</span>) <span class="hljs-comment"># 按照行读取和填充</span><br></code></pre></td></tr></table></figure><p>array([[0, 1],<br>           [2, 3],<br>           [4, 5],<br>           [6, 7]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), order=<span class="hljs-string">'F'</span>) <span class="hljs-comment"># 按照列读取和填充</span><br></code></pre></td></tr></table></figure><p>array([[0, 2],<br>           [4, 6],<br>           [1, 3],<br>           [5, 7]])</p><p>特别地，由于被调用数组的大小是确定的， reshape 允许有一个维度存在空缺，此时只需填充-1即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>))<br></code></pre></td></tr></table></figure><p>array([[0, 1],<br>           [2, 3],<br>           [4, 5],<br>           [6, 7]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target<br></code></pre></td></tr></table></figure><p>array([[1.],<br>           [1.],<br>           [1.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target.reshape(<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><p>array([1., 1., 1.])</p><h2 id="3-np数组的切片与索引"><a href="#3-np数组的切片与索引" class="headerlink" title="3. np数组的切片与索引"></a>3. np数组的切片与索引</h2><p>数组的切片模式支持使用 <code>slice</code> 类型的 <code>start:end:step</code> 切片，还可以直接传入列表指定某个维度的索引进行切片：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target = np.arange(<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target<br></code></pre></td></tr></table></figure><p>array([[0, 1, 2],<br>           [3, 4, 5],<br>           [6, 7, 8]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target[:<span class="hljs-number">-1</span>, [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]<br></code></pre></td></tr></table></figure><p>array([[0, 2],<br>           [3, 5]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>,:]<br></code></pre></td></tr></table></figure><p>array([[0, 1, 2]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>,[<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure><p>array([[0],<br>           [3]])</p><p>此外，还可以利用 <code>np.ix_</code> 在对应的维度上使用布尔索引，但此时不能使用 <code>slice</code> 切片：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target[np.ix_([<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>], [<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>])]<br></code></pre></td></tr></table></figure><p>array([[0, 2],<br>           [6, 8]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target[np.ix_([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>])]<br></code></pre></td></tr></table></figure><p>array([[3, 5],<br>           [6, 8]])</p><p>当数组维度为1维时，可以直接进行布尔索引，而无需 <code>np.ix_ </code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">new = target.reshape(<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">new[new%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>array([0, 2, 4, 6, 8])</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p><code>where</code> 是一种条件函数，可以指定满足条件与不满足条件位置对应的填充值：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.where(a&gt;<span class="hljs-number">0</span>, a, <span class="hljs-number">5</span>) <span class="hljs-comment"># 对应位置为True时填充a对应元素，否则填充5</span><br></code></pre></td></tr></table></figure><p>array([5, 1, 5, 5])</p><p><code>nonzero, argmax, argmin</code></p><p>这三个函数返回的都是索引， <code>nonzero</code> 返回非零数的索引， <code>argmax, argmin</code> 分别返回最大和最小数的索引：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">-2</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nonzero(a)<br></code></pre></td></tr></table></figure><p>(array([0, 1, 3, 4, 5], dtype=int64),)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a.argmax()<br></code></pre></td></tr></table></figure><pre><code>4</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a.argmin()<br></code></pre></td></tr></table></figure><p>1</p><p>any 指当序列<strong>至少</strong> 存在一个 True 或非零元素时返回 True ，否则返回 False</p><p>all 指当序列元素 <strong>全为</strong> True 或非零元素时返回 True ，否则返回 False</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a.any()<br></code></pre></td></tr></table></figure><p>True</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a.all()<br></code></pre></td></tr></table></figure><p>False</p><p><code>cumprod, cumsum</code> 分别表示累乘和累加函数，返回同长度的数组， <code>diff</code> 表示和前一个元素做差，由于第一个元素为缺失值，因此在默认参数情况下，返回长度是原数组减1</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a.cumsum()<br></code></pre></td></tr></table></figure><p>array([1, 3, 6], dtype=int32)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a.cumprod()<br></code></pre></td></tr></table></figure><p>array([1, 2, 6], dtype=int32)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.diff(a)<br></code></pre></td></tr></table></figure><p>array([1, 1])</p><h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>常用的统计函数包括 <code>max, min, mean, median, std, var, sum, quantile</code> ，其中分位数计算是全局方法，因此不能通过 <code>array.quantile</code> 的方法调用：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target = np.arange(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target<br></code></pre></td></tr></table></figure><p>array([0, 1, 2, 3, 4])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target.max()<br></code></pre></td></tr></table></figure><p>4</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.quantile(target, <span class="hljs-number">0.15</span>) <span class="hljs-comment"># 0.5分位数</span><br></code></pre></td></tr></table></figure><p>0.6</p><p>但是对于含有缺失值的数组，它们返回的结果也是缺失值，如果需要略过缺失值，必须使用 <code>nan*</code> 类型的函数，上述的几个统计函数都有对应的 <code>nan*</code> 函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, np.nan])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target<br></code></pre></td></tr></table></figure><p>array([ 1.,  2., nan])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target.max()<br></code></pre></td></tr></table></figure><p>nan</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nanmax(target)<br></code></pre></td></tr></table></figure><p>2.0</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nanquantile(target, <span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p>1.5</p><p>对于协方差和相关系数分别可以利用 <code>cov, corrcoef </code>如下计算：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target1 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target2 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-9</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.cov(target1, target2)<br></code></pre></td></tr></table></figure><p>array([[ 11.66666667, -16.66666667],<br>           [-16.66666667,  38.66666667]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.corrcoef(target1, target2)<br></code></pre></td></tr></table></figure><p>array([[ 1.        , -0.78470603],<br>           [-0.78470603,  1.        ]])</p><p>最后，需要说明二维 <code>Numpy</code> 数组中统计函数的 <code>axis</code> 参数，它能够进行某一个维度下的统计特征计算，当 <code>axis=0</code> 时结果为列的统计指标，当 <code>axis=1</code>时结果为行的统计指标：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target = np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target<br></code></pre></td></tr></table></figure><p>array([[1, 2, 3],<br>           [4, 5, 6],<br>           [7, 8, 9]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target.sum(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>array([12, 15, 18])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target.sum(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>array([ 6, 15, 24])</p><h2 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h2><p>标量和数组的操作<br>当一个标量和数组进行运算时，标量会自动把大小扩充为数组大小，之后进行逐元素操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res = <span class="hljs-number">3</span> * np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res<br></code></pre></td></tr></table></figure><p>array([[4., 4.],<br>           [4., 4.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res = <span class="hljs-number">1</span> / res<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res<br></code></pre></td></tr></table></figure><p>array([[0.25, 0.25],<br>           [0.25, 0.25]])</p><p>二维数组之间的操作</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res * np.array([[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]) <span class="hljs-comment"># 第二个数组扩充第一维度为3</span><br></code></pre></td></tr></table></figure><p>array([[2., 3.],<br>           [2., 3.],<br>           [2., 3.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res * np.array([[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>]]) <span class="hljs-comment"># 第二个数组扩充第二维度为2</span><br></code></pre></td></tr></table></figure><p>array([[2., 2.],<br>           [3., 3.],<br>           [4., 4.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res * np.array([[<span class="hljs-number">2</span>]]) <span class="hljs-comment"># 等价于两次扩充，第二个数组两个维度分别扩充为3和2</span><br></code></pre></td></tr></table></figure><p>array([[2., 2.],<br>           [2., 2.],<br>           [2., 2.]])</p><p>一维数组与二维数组的操作</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.ones(<span class="hljs-number">3</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>array([[2., 2., 2.],<br>           [2., 2., 2.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.ones(<span class="hljs-number">3</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>array([[2., 2., 2.],<br>           [2., 2., 2.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.ones(<span class="hljs-number">1</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>array([[2., 2., 2.],<br>           [2., 2., 2.]])</p><h2 id="向量与矩阵的计算"><a href="#向量与矩阵的计算" class="headerlink" title="向量与矩阵的计算"></a>向量与矩阵的计算</h2><p>向量内积：<code>dot</code></p><p>$$ a · b = \Sigma_i{a_ib_i}$$</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">b = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a.dot(b)<br></code></pre></td></tr></table></figure><p>22</p><p>向量范数和矩阵范数: <code>np.linalg.norm</code></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">matrix_target =  np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">matrix_target<br></code></pre></td></tr></table></figure><p>array([[0, 1],<br>           [2, 3]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.linalg.norm(matrix_target, <span class="hljs-string">'fro'</span>)<br></code></pre></td></tr></table></figure><p>3.7416573867739413</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.linalg.norm(matrix_target, np.inf)<br></code></pre></td></tr></table></figure><p>5.0</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.linalg.norm(matrix_target, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>3.702459173643833</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">vector_target =  np.arange(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">vector_target<br></code></pre></td></tr></table></figure><p>array([0, 1, 2, 3])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.linalg.norm(vector_target, np.inf)<br></code></pre></td></tr></table></figure><p>3.0</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.linalg.norm(vector_target, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>3.7416573867739413</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.linalg.norm(vector_target, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>3.3019272488946263</p><p>矩阵乘法</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">b = np.arange(<span class="hljs-number">-4</span>,<span class="hljs-number">0</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a<br></code></pre></td></tr></table></figure><p>array([[0, 1],<br>           [2, 3]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">b<br></code></pre></td></tr></table></figure><p>array([[-4, -3],<br>           [-2, -1]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a@b<br></code></pre></td></tr></table></figure><p>array([[ -2,  -1],<br>           [-14,  -9]])</p><h2 id="Ex1：利用列表推导式写矩阵乘法"><a href="#Ex1：利用列表推导式写矩阵乘法" class="headerlink" title="Ex1：利用列表推导式写矩阵乘法"></a>Ex1：利用列表推导式写矩阵乘法</h2><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">M1 = np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">M2 = np.random.rand(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res = np.zeros((M1.shape[<span class="hljs-number">0</span>],M2.shape[<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res.shape<br></code></pre></td></tr></table></figure><p>(2, 4)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res<br></code></pre></td></tr></table></figure><p>array([[0., 0., 0., 0.],<br>           [0., 0., 0., 0.]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">i=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multifuc</span><span class="hljs-params">(i,j,k)</span>:</span><br>    res[i][j]+=M1[i][k] * M2[k][j]<br>    <span class="hljs-keyword">return</span> res[i][j]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">%timeit -n <span class="hljs-number">30</span> [ multifuc(i,j,k)  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(M1.shape[<span class="hljs-number">0</span>])  <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(M2.shape[<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(M1.shape[<span class="hljs-number">1</span>])]<br></code></pre></td></tr></table></figure><p>83.3 µs ± 33.6 µs per loop (mean ± std. dev. of 7 runs, 30 loops each)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">(np.abs((M1@M2 - res) &lt; <span class="hljs-number">1e-15</span>)).all()<br></code></pre></td></tr></table></figure><p>True</p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">i=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sum([M1[i][k] * M2[k][j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(M2.shape[<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(M1.shape[<span class="hljs-number">1</span>])])<br></code></pre></td></tr></table></figure><p>3.745920492921166</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">%timeit -n <span class="hljs-number">30</span> [sum([M1[i][k] * M2[k][j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(M2.shape[<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(M1.shape[<span class="hljs-number">1</span>])]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(M1.shape[<span class="hljs-number">0</span>])  <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(M2.shape[<span class="hljs-number">1</span>]) ]<br></code></pre></td></tr></table></figure><p>203 µs ± 33.3 µs per loop (mean ± std. dev. of 7 runs, 30 loops each)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">(np.abs((M1@M2 - res) &lt; <span class="hljs-number">1e-15</span>)).all()<br></code></pre></td></tr></table></figure><p>True</p><p>很明显第一种方法会比datawhale官方的要少一个循环，虽然这样确实有点取巧</p><h2 id="Ex2：更新矩阵"><a href="#Ex2：更新矩阵" class="headerlink" title="Ex2：更新矩阵"></a>Ex2：更新矩阵</h2><h3 id="Ex2：更新矩阵-1"><a href="#Ex2：更新矩阵-1" class="headerlink" title="Ex2：更新矩阵"></a>Ex2：更新矩阵</h3><p>设矩阵 $A_{m×n}$ ，现在对 $A$ 中的每一个元素进行更新生成矩阵 $B$ ，更新方法是 $B_{ij}=A_{ij}\sum_{k=1}^n\frac{1}{A_{ik}}$ ，例如下面的矩阵为 $A$ ，则 $B_{2,2}=5\times(\frac{1}{4}+\frac{1}{5}+\frac{1}{6})=\frac{37}{12}$ ，请利用 <code>Numpy</code> 高效实现。<br>$$<br> A=\left[<br> \begin{matrix}<br>   1 &amp; 2 &amp; 3 \<br>   4 &amp; 5 &amp; 6 \<br>   7 &amp; 8 &amp; 9<br>  \end{matrix}<br>  \right]<br>$$</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A=np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>)<span class="hljs-comment">#start从0开始，默认不包含end</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A<br></code></pre></td></tr></table></figure><p>array([[1, 2, 3],<br>           [4, 5, 6],<br>           [7, 8, 9]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A_reverse = <span class="hljs-number">1</span>/A<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A_reverse<br></code></pre></td></tr></table></figure><p>array([[1.        , 0.5       , 0.33333333],<br>           [0.25      , 0.2       , 0.16666667],<br>           [0.14285714, 0.125     , 0.11111111]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A_reverse.sum(axis=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><p>array([[1.83333333],<br>           [0.61666667],<br>           [0.37896825]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res =A*(A_reverse.sum(axis=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res<br></code></pre></td></tr></table></figure><p>array([[1.83333333, 3.66666667, 5.5       ],<br>           [2.46666667, 3.08333333, 3.7       ],<br>           [2.65277778, 3.03174603, 3.41071429]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res.shape<br></code></pre></td></tr></table></figure><p>(3, 3)</p><h2 id="Ex3：卡方统计量"><a href="#Ex3：卡方统计量" class="headerlink" title="Ex3：卡方统计量"></a>Ex3：卡方统计量</h2><p>设矩阵$A_{m\times n}$，记$B_{ij} = \frac{(\sum_{i=1}^mA_{ij})\times (\sum_{j=1}^nA_{ij})}{\sum_{i=1}^m\sum_{j=1}^nA_{ij}}$，定义卡方值如下：<br>$$\chi^2 = \sum_{i=1}^m\sum_{j=1}^n\frac{(A_{ij}-B_{ij})^2}{B_{ij}}$$<br>请利用<code>Numpy</code>对给定的矩阵$A$计算$\chi^2$ </p><p>$(\sum_{i=1}^mA_{ij})\times (\sum_{j=1}^nA_{ij}) shape (8 \times 1) \times(1 \times 5)$ </p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A = np.random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, (<span class="hljs-number">8</span>, <span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>通过分析我们可以看出其实矩阵$B$就是矩阵$A$通过对行和列求和再叉乘，然后除以所有元素的和</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A_rowsum=A.sum(axis=<span class="hljs-number">0</span>).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A_columnsum=A.sum(axis=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A_columnsum.shape,A_rowsum.shape<br></code></pre></td></tr></table></figure><p>((8, 1), (1, 5))</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A_rowsum*A_columnsum <span class="hljs-comment">#有点离谱</span><br><span class="hljs-comment">#主要是*号对应数组用数组乘法，矩阵用矩阵乘法</span><br></code></pre></td></tr></table></figure><p>array([[ 8160,  7548,  8772,  7888,  6868],<br>           [ 8760,  8103,  9417,  8468,  7373],<br>           [ 9600,  8880, 10320,  9280,  8080],<br>           [ 9480,  8769, 10191,  9164,  7979],<br>           [10200,  9435, 10965,  9860,  8585],<br>           [ 7320,  6771,  7869,  7076,  6161],<br>           [ 8040,  7437,  8643,  7772,  6767],<br>           [ 7680,  7104,  8256,  7424,  6464]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">(A_rowsum*A_columnsum).shape<br></code></pre></td></tr></table></figure><p>(8, 5)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">A_columnsum@A_rowsum <span class="hljs-comment">#比较推荐这种</span><br></code></pre></td></tr></table></figure><p>array([[ 8160,  7548,  8772,  7888,  6868],<br>           [ 8760,  8103,  9417,  8468,  7373],<br>           [ 9600,  8880, 10320,  9280,  8080],<br>           [ 9480,  8769, 10191,  9164,  7979],<br>           [10200,  9435, 10965,  9860,  8585],<br>           [ 7320,  6771,  7869,  7076,  6161],<br>           [ 8040,  7437,  8643,  7772,  6767],<br>           [ 7680,  7104,  8256,  7424,  6464]])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">B=(A_columnsum@A_rowsum)/A.sum()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">B.shape==A.shape<br></code></pre></td></tr></table></figure><p>True</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">res = ((A-B)**<span class="hljs-number">2</span>/B).sum()<br>res<br></code></pre></td></tr></table></figure><p>11.842696601945802</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>A = np.random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, (<span class="hljs-number">8</span>, <span class="hljs-number">5</span>))<br>B = A.sum(<span class="hljs-number">0</span>)*A.sum(<span class="hljs-number">1</span>).reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)/A.sum() <span class="hljs-comment">#个人认为这样写其实会误导初学者</span><br>res = ((A-B)**<span class="hljs-number">2</span>/B).sum()<br>res<br></code></pre></td></tr></table></figure><p>11.842696601945802</p><h2 id="Ex4：改进矩阵计算的性能"><a href="#Ex4：改进矩阵计算的性能" class="headerlink" title="Ex4：改进矩阵计算的性能"></a>Ex4：改进矩阵计算的性能</h2><h3 id="原方法"><a href="#原方法" class="headerlink" title="原方法"></a>原方法</h3><p><img src="https://img-blog.csdnimg.cn/20201221120104121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eDkWiRZe-1608522933099)(attachment:image.png)]"></p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>m,n,p=<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">50</span><br>B=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,(m,p))<br>U=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,(p,n))<br>Z=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,(m,n))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solution</span><span class="hljs-params">(B=B, U=U, Z=Z)</span>:</span><br>    L_res = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):<br>            norm_value = ((B[i]-U[:,j])**<span class="hljs-number">2</span>).sum()<br>            L_res.append(norm_value*Z[i][j])<br>    <span class="hljs-keyword">return</span> sum(L_res)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">solution(B, U, Z)<br></code></pre></td></tr></table></figure><p>100566</p><p><img src="https://img-blog.csdnimg.cn/20201221120126404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>从上式可以看出，第一第二项分别为$B$的行平方和与$U$的列平方和，第三项是两倍的内积。因此，$Y$矩阵可以写为三个部分，第一个部分是$m×n$的全$1$矩阵每行乘以$B$对应行的行平方和，第二个部分是相同大小的全$1$矩阵每列乘以$U$对应列的列平方和，第三个部分恰为$B$矩阵与$U$矩阵乘积的两倍。从而结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">B[<span class="hljs-number">1</span>].shape<br></code></pre></td></tr></table></figure><p>(50,)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">U[:,<span class="hljs-number">1</span>].shape<br></code></pre></td></tr></table></figure><p>(50,)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">(((B**<span class="hljs-number">2</span>).sum(axis=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)+(U**<span class="hljs-number">2</span>).sum(axis=<span class="hljs-number">0</span>)<span class="hljs-number">-2</span>*B@U)*Z).sum()<br></code></pre></td></tr></table></figure><p>100566</p><h2 id="连续整数的最大长度"><a href="#连续整数的最大长度" class="headerlink" title="连续整数的最大长度"></a>连续整数的最大长度</h2><p>输入一个整数的 <code>Numpy</code> 数组，返回其中严格递增连续整数子数组的最大长度。例如，输入 [1,2,5,6,7]，[5,6,7]为具有最大长度的递增连续整数子数组，因此输出3；输入[3,2,1,2,3,4,6]，[1,2,3,4]为具有最大长度的递增连续整数子数组，因此输出4。请充分利用 Numpy 的内置函数完成。（提示：考虑使用 <code>nonzero, diff</code> 函数）</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> x:np.diff(np.nonzero(np.r_[<span class="hljs-number">1</span>,np.diff(x)!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])).max()<br>f([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>])<br>f([<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>])<br></code></pre></td></tr></table></figure><p>4</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.diff(x)<br></code></pre></td></tr></table></figure><p>array([1, 3, 1, 1])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.diff(x)!=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>array([False,  True, False, False])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.r_[<span class="hljs-number">1</span>,np.diff(x)!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>array([1, 0, 1, 0, 0, 1], dtype=int32)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nonzero(np.r_[<span class="hljs-number">1</span>,np.diff(x)!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>(array([0, 2, 5], dtype=int64),)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.diff(np.nonzero(np.r_[<span class="hljs-number">1</span>,np.diff(x)!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])).max()<br></code></pre></td></tr></table></figure><p>3</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><br><br></code></pre></td></tr></table></figure><p>1.842696601945802</p><h2 id="Ex4：改进矩阵计算的性能-1"><a href="#Ex4：改进矩阵计算的性能-1" class="headerlink" title="Ex4：改进矩阵计算的性能"></a>Ex4：改进矩阵计算的性能</h2><h3 id="原方法-1"><a href="#原方法-1" class="headerlink" title="原方法"></a>原方法</h3><p>[外链图片转存中…(img-eDkWiRZe-1608522933099)]</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.random.seed(<span class="hljs-number">0</span>)<br>m,n,p=<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">50</span><br>B=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,(m,p))<br>U=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,(p,n))<br>Z=np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,(m,n))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solution</span><span class="hljs-params">(B=B, U=U, Z=Z)</span>:</span><br>    L_res = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):<br>            norm_value = ((B[i]-U[:,j])**<span class="hljs-number">2</span>).sum()<br>            L_res.append(norm_value*Z[i][j])<br>    <span class="hljs-keyword">return</span> sum(L_res)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">solution(B, U, Z)<br></code></pre></td></tr></table></figure><p>100566</p><p>改进方法：</p><p>令$Y_{ij} = |B_i-U_j|<em>2^2$，则$\displaystyle R=\sum</em>{i=1}^m\sum_{j=1}^n Y_{ij}Z_{ij}$，这在<code>Numpy</code>中可以用逐元素的乘法后求和实现，因此问题转化为了如何构造<code>Y</code>矩阵。</p><p>$$<br>\begin{split}Y_{ij} &amp;= |B_i-U_j|<em>2^2\<br>&amp;=\sum</em>{k=1}^p(B_{ik}-U_{kj})^2\<br>&amp;=\sum_{k=1}^p B_{ik}^2+\sum_{k=1}^p U_{kj}^2-2\sum_{k=1}^p B_{ik}U_{kj}\\end{split}<br>$$</p><p>从上式可以看出，第一第二项分别为$B$的行平方和与$U$的列平方和，第三项是两倍的内积。因此，$Y$矩阵可以写为三个部分，第一个部分是$m×n$的全$1$矩阵每行乘以$B$对应行的行平方和，第二个部分是相同大小的全$1$矩阵每列乘以$U$对应列的列平方和，第三个部分恰为$B$矩阵与$U$矩阵乘积的两倍。从而结果如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">B[<span class="hljs-number">1</span>].shape<br></code></pre></td></tr></table></figure><p>(50,)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">U[:,<span class="hljs-number">1</span>].shape<br></code></pre></td></tr></table></figure><p>(50,)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">(((B**<span class="hljs-number">2</span>).sum(axis=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)+(U**<span class="hljs-number">2</span>).sum(axis=<span class="hljs-number">0</span>)<span class="hljs-number">-2</span>*B@U)*Z).sum()<br></code></pre></td></tr></table></figure><p>100566</p><h2 id="连续整数的最大长度-1"><a href="#连续整数的最大长度-1" class="headerlink" title="连续整数的最大长度"></a>连续整数的最大长度</h2><p>输入一个整数的 <code>Numpy</code> 数组，返回其中严格递增连续整数子数组的最大长度。例如，输入 [1,2,5,6,7]，[5,6,7]为具有最大长度的递增连续整数子数组，因此输出3；输入[3,2,1,2,3,4,6]，[1,2,3,4]为具有最大长度的递增连续整数子数组，因此输出4。请充分利用 Numpy 的内置函数完成。（提示：考虑使用 <code>nonzero, diff</code> 函数）</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> x:np.diff(np.nonzero(np.r_[<span class="hljs-number">1</span>,np.diff(x)!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])).max()<br>f([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>])<br>f([<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>])<br></code></pre></td></tr></table></figure><p>4</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.diff(x)<br></code></pre></td></tr></table></figure><p>array([1, 3, 1, 1])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.diff(x)!=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>array([False,  True, False, False])</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.r_[<span class="hljs-number">1</span>,np.diff(x)!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>array([1, 0, 1, 0, 0, 1], dtype=int32)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.nonzero(np.r_[<span class="hljs-number">1</span>,np.diff(x)!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>(array([0, 2, 5], dtype=int64),)</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">np.diff(np.nonzero(np.r_[<span class="hljs-number">1</span>,np.diff(x)!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])).max()<br></code></pre></td></tr></table></figure><p>3</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;datawhale-pandas数据分析预备&quot;&gt;&lt;a href=&quot;#datawhale-pandas数据分析预备&quot; class=&quot;headerlink&quot; title=&quot;datawhale-pandas数据分析预备&quot;&gt;&lt;/a&gt;datawhale-pandas数据分析预备&lt;/h2&gt;&lt;h2 id=&quot;列表推导式&quot;&gt;&lt;a href=&quot;#列表推导式&quot; class=&quot;headerlink&quot; title=&quot;列表推导式&quot;&gt;&lt;/a&gt;列表推导式&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs python&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;my_func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*x&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;for-i-in&quot;&gt;&lt;a href=&quot;#for-i-in&quot; class=&quot;headerlink&quot; title=&quot;[* for i in *]&quot;&gt;&lt;/a&gt;[* for i in *]&lt;/h2&gt;&lt;p&gt;其中，第一个 * 为映射函数，其输入为后面 i 指代的内容，第二个 * 表示迭代的对象。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="pandas" scheme="https://yoursite.com/tags/pandas/"/>
    
      <category term="datawhale" scheme="https://yoursite.com/tags/datawhale/"/>
    
  </entry>
  
  <entry>
    <title>信号量机制经典例子</title>
    <link href="https://yoursite.com/2020/11/06/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/"/>
    <id>https://yoursite.com/2020/11/06/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E7%BB%8F%E5%85%B8%E4%BE%8B%E5%AD%90/</id>
    <published>2020-11-05T16:27:36.000Z</published>
    <updated>2021-01-19T04:31:32.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h2><p>7.8 The Sleeping-Barber Problem. A barbershop consists of a waiting room with n chairs and the barber room containing the barber chair. If there are no customers to be served,the barber goes to sleep. If a customer enters the barbershop and all chairs are occupied, then the customer leaves the shop.If the barber is busy but chairs are available, then the customer sits in one of the free chairs. If the barber is asleep, the customer wakes up the barber. Write a program to coordinate the barber and the customers.</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">semaphore:<br>    full:=<span class="hljs-number">0</span>,empty:=n,mutex:=<span class="hljs-number">1</span>;<span class="hljs-comment">//刘军的写法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*full表示当前需要理发的人数</span><br><span class="hljs-comment">*empty表示当前还剩下多少空椅子</span><br><span class="hljs-comment">*mutex进程互斥控制量，理发师一次只能给一个人理发</span><br><span class="hljs-comment">*/</span><br>Parbegin:<br>    customer: repeat<br>            <span class="hljs-keyword">if</span> empty=<span class="hljs-number">0</span>:<br>                customer leaves the shop<span class="hljs-comment">//没有空位置则离开</span><br>            P(empty);<br>            P(mutex);<br>            add a customer to chair<br>            V(mutex);<br>            V(full);<br>            until <span class="hljs-literal">false</span>;<br>    <br>    barber: repeat<br>            <span class="hljs-keyword">if</span> full=<span class="hljs-number">0</span>:<br>                barber sleep;<span class="hljs-comment">//没有人需要理发则睡觉</span><br>            P(full);<br>            P(mutex);<br>            cutting hair<br>            V(mutex);<br>            V(empty);<br>            until <span class="hljs-literal">false</span>;<br>Parend;<br></code></pre></td></tr></table></figure><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">type item=...;<br>var <span class="hljs-built_in">buffer</span>=...;<br><br>full,empty,mutex:semaphore;<br>nextp,nextc:item;<br><span class="hljs-built_in">begin</span>:<br>    full:=<span class="hljs-number">0</span>;empty:=n;mutex:=<span class="hljs-number">1</span>;<br>Parbegin:<br>    producer:repeat<br>        ...<br>        produce an item in nextp;<br>        ...<br>        p(empty);<br>        p(mutex);<br>        add nextp to <span class="hljs-built_in">buffer</span>;<br>        V(mutex);<br>        V(full);<br>        until <span class="hljs-literal">false</span>;<br>    <br>    consumer:repeat<br>        ...<br>        p(full);<br>        p(mutex);<br>        <span class="hljs-built_in">remove</span> an item from <span class="hljs-built_in">buffer</span> to nextc;<br>        释放缓冲区<br>        V(mutex);<br>        P(empty);<br>        ...<br>        consume the item in nextc;<br>        ...<br>        until <span class="hljs-literal">false</span>;<br>Parend<br></code></pre></td></tr></table></figure><h2 id="读者写者"><a href="#读者写者" class="headerlink" title="读者写者"></a>读者写者</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">semaphore mutex:=<span class="hljs-number">1</span>,wrt:=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> readcount:=<span class="hljs-number">0</span>;<br>Parbegin:<br>    Writer:repeat<br>        P(wrt);<br>        写数据<br>        V(wrt);<br>    <br>    Reader:repeat<br>        P(mutex);<br>        readcount:=readcount+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> readcount:=<span class="hljs-number">1</span> then P(wrt);<br>        V(mutex);<br>        读数据<br>        P(mutex);<br>        readcount:=readcount<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> readcount=<span class="hljs-number">0</span> then V(wrt);<br>        V(mutex);<br>Parend<br></code></pre></td></tr></table></figure><h2 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">semaphore chopstick[<span class="hljs-number">5</span>];<span class="hljs-comment">//初始信号量都为1</span><br>第i个进程描述为(i=<span class="hljs-number">0</span>,… ,<span class="hljs-number">4</span>)<br>   repeat<br>  P(chopstick[i]);<br>  P(chopstick[(i+<span class="hljs-number">1</span>) mod <span class="hljs-number">5</span>]);<br>  吃<br>  V(chopstick[i]);<br>  V(Chopstick[(i+<span class="hljs-number">1</span>) mod <span class="hljs-number">5</span>];<br>  思考<br>   until <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理发师问题&quot;&gt;&lt;a href=&quot;#理发师问题&quot; class=&quot;headerlink&quot; title=&quot;理发师问题&quot;&gt;&lt;/a&gt;理发师问题&lt;/h2&gt;&lt;p&gt;7.8 The Sleeping-Barber Problem. A barbershop consists of a waiting room with n chairs and the barber room containing the barber chair. If there are no customers to be served,the barber goes to sleep. If a customer enters the barbershop and all chairs are occupied, then the customer leaves the shop.If the barber is busy but chairs are available, then the customer sits in one of the free chairs. If the barber is asleep, the customer wakes up the barber. Write a program to coordinate the barber and the customers.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据库复习题</title>
    <link href="https://yoursite.com/2020/11/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E9%A2%98/"/>
    <id>https://yoursite.com/2020/11/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E9%A2%98/</id>
    <published>2020-11-01T11:16:40.000Z</published>
    <updated>2021-01-19T04:31:32.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复习题"><a href="#复习题" class="headerlink" title="复习题"></a>复习题</h2><p>Use only the INVENTORY table to answer Review Questions 2.17 through 2.40:</p><a id="more"></a><p>2.17 Write an SQL statement to display SKU and SKU_Description.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SKU,SKU_Description <span class="hljs-keyword">FROM</span> INVENTORY;<br></code></pre></td></tr></table></figure><p>2.18    Write an SQL statement to display SKU_Description and SKU.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SKU_Description,SKU <span class="hljs-keyword">FROM</span> INVENTORY;<br></code></pre></td></tr></table></figure><p>2.19    Write an SQL statement to display WarehouseID.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> WarehouseID <span class="hljs-keyword">FROM</span> INVENTORY;<br></code></pre></td></tr></table></figure><p>2.20    Write an SQL statement to display unique WarehouseIDs.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> WarehouseID <span class="hljs-keyword">FROM</span> INVENTORY;<br></code></pre></td></tr></table></figure><p>2.26    Write an SQL statement to display the SKU, SKU_Description, and WarehouseID for products that have a QuantityOnHand greater than 0. Sort the results in descending order by WarehouseID and in ascending order by SKU.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SKU, SKU_Description, WarehouseID<br><span class="hljs-keyword">FROM</span> INVENTORY<br><span class="hljs-keyword">WHERE</span> QuantityOnHand&gt;<span class="hljs-number">0</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> WarehouseID <span class="hljs-keyword">DESC</span>, SKU <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><p>2.29 Write an SQL statement to display the SKU, SKU_Description, WarehouseID, and QuantityOnHand for all products having a QuantityOnHand greater than 1 and less than 10. Do not use the BETWEEN keyword. </p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SKU, SKU_Description, WarehouseID, QuantityOnHand<br><span class="hljs-keyword">FROM</span> INVENTORY<br><span class="hljs-keyword">WHERE</span> QuantityOnHand&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> QuantityOnOrder&lt;<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>2.36    Write an SQL statement to display the WarehouseID and the sum of QuantityOnHand,grouped by WarehouseID. Name the sum TotalItemsOnHand and display the results in descending order of TotalItemsOnHand.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> WarehouseID , <span class="hljs-keyword">SUM</span> (QuantityOnHand) <span class="hljs-keyword">AS</span> TotalItamsOnHand<br><span class="hljs-keyword">FROM</span> INVENTORY<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> WarehouseID<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> TotalItemsOnHand <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p><strong>2.37 Write an SQL statement to display the WarehouseID and the sum of QuantityOnHand, grouped by WarehouseID. Omit all SKU items that have 3 or more items on hand from the sum, and name the sum TotalItemsOnHandLT3 and display the results in descending order of TotalItemsOnHandLT3.</strong> </p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> WarehouseID , <span class="hljs-keyword">SUM</span> (QuantityOnHand) <span class="hljs-keyword">AS</span> TotalItamsOnHandLT3<br><span class="hljs-keyword">FROM</span> INVENTORY<br><span class="hljs-keyword">WHERE</span> QuantityOnHand&lt;<span class="hljs-number">3</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> WarehouseID<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> TotalItemsOnHandLT3 <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p><strong>2.38 Write an SQL statement to display the WarehouseID and the sum of QuantityOnHand grouped by WarehouseID. Omit all SKU items that have 3 or more items on hand from the sum, and name the sum TotalItemsOnHandLT3. Show WarehouseID only for warehouses having fewer than 2 SKUs in their TotalItemesOnHandLT3 and display the results in descending order of TotalItemsOnHandLT3.</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> WarehouseID , <span class="hljs-keyword">SUM</span> (QuantityOnHand) <span class="hljs-keyword">AS</span> TotalItamsOnHandLT3,<br><span class="hljs-keyword">FROM</span> INVENTORY<br><span class="hljs-keyword">WHERE</span> QuantityOnHand &lt;<span class="hljs-number">3</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> WarehouseID<br><span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(*)&lt;<span class="hljs-number">2</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> TotalItemsOnHandLT3 <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p>Use both the INVENTORY and WAREHOUSE tables to answer Review Questions 2.40 through 2.52: </p><p>2.42 Write an SQL statement to display the SKU, SKU_Description, WarehouseID, Ware-houseCity, and WarehouseState of all items not stored in the Atlanta, Bangor, or Chicago warehouse. Do not use the NOT IN keyword. </p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SKU, SKU_Description, INVENTORY.WarehouseID, WarehouseCity, WarehouseState<br><span class="hljs-keyword">FROM</span> INVENTORY, WAREHOUSE<br><span class="hljs-keyword">WHERE</span> INVENTORY.WarehouseID=WAREHOUSE.WarehouseID <span class="hljs-keyword">AND</span> WarehouseCity!=<span class="hljs-string">'Atlanta'</span> <span class="hljs-keyword">AND</span> WarehouseCity!=<span class="hljs-string">'Chicago'</span> <span class="hljs-keyword">AND</span> WarehouseCity!=<span class="hljs-string">'Bangor'</span>;<br></code></pre></td></tr></table></figure><p>2.44 Write an SQL statement to produce a single column called ItemLocation that combines the SKU_Description, the phrase “is in a warehouse in”, and WarehouseCity. Do not be concerned with removing leading or trailing blanks. </p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">RTRIM</span>(SKU_Description)+ <span class="hljs-string">'is in a warehouse'</span> + <span class="hljs-keyword">RTRIM</span>(WarehouseCity) <span class="hljs-keyword">AS</span> ItemLocation<br><span class="hljs-keyword">FROM</span> INVENTORY, WAREHOUSE <span class="hljs-keyword">WHERE</span> INVENTORY.WarehouseID=WAREHOUSE.WarehouseID;<br></code></pre></td></tr></table></figure><p>2.45 Write an SQL statement to show the SKU, SKU_Description, WarehouseID for all items stored in a warehouse managed by ‘Lucille Smith’. Use a subquery.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SKU, SKU_Description, WarehouseID<br><span class="hljs-keyword">FROM</span> INVENTORY<br><span class="hljs-keyword">WHERE</span> WarehouseID <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> WarehouseID<br><span class="hljs-keyword">FROM</span> WAREHOUSE <span class="hljs-keyword">WHERE</span> Manager=<span class="hljs-string">'Lucille Smith'</span>);<br></code></pre></td></tr></table></figure><p>2.46 Write an SQL statement to show the SKU, SKU_Description, WarehouseID for all items stored in a warehouse managed by ‘Lucille Smith’. Use a join. </p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SKU, SKU_Description, INVENTORY.WarehouseID<br><span class="hljs-keyword">FROM</span> INVENTORY, WAREHOUSE<br><span class="hljs-keyword">WHERE</span> INVENTORY.WarehouseID=WAREHOUSE.WarehouseID <span class="hljs-keyword">AND</span> WAREHOUSE.Manager= <span class="hljs-string">'Lucille Smith'</span>;<br></code></pre></td></tr></table></figure><p>2.50 Write an SQL statement to show the WarehouseID and average QuantityOnHand of all items stored in a warehouse managed by ‘Lucille Smith’. Use a join using JOIN ON syntax.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> INVENTORY.WarehouseID, <span class="hljs-keyword">AVG</span>(QuantityOnHand)<br><span class="hljs-keyword">FROM</span> INVENTORY <span class="hljs-keyword">JOIN</span> WAREHOUSE<br><span class="hljs-keyword">ON</span> INVENTORY.WarehouseID=WAREHOUSE.WarehouseID <br><span class="hljs-keyword">WHERE</span> WAREHOUSE.Manager=<span class="hljs-string">'Lucille Smith'</span>;<br></code></pre></td></tr></table></figure><p>2.55 Write an SQL statement to join WAREHOUSE and INVENTORY and include all rows of WAREHOUSE in your answer, regardless of whether they have any INVENTORY. Run this statement.</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> WAREHOUSE <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> INWENTORY <br><span class="hljs-keyword">ON</span> INVENTORY.WarehouseID=WAREHOUSE.WarehouseID;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;复习题&quot;&gt;&lt;a href=&quot;#复习题&quot; class=&quot;headerlink&quot; title=&quot;复习题&quot;&gt;&lt;/a&gt;复习题&lt;/h2&gt;&lt;p&gt;Use only the INVENTORY table to answer Review Questions 2.17 through 2.40:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库系统" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>自顶向下的语法分析</title>
    <link href="https://yoursite.com/2020/10/22/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://yoursite.com/2020/10/22/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2020-10-22T08:46:02.000Z</published>
    <updated>2021-01-19T04:31:32.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LL-1-文法的定义"><a href="#LL-1-文法的定义" class="headerlink" title="LL(1)文法的定义"></a>LL(1)文法的定义</h2><p>一个上下文无关文法G是LL(1)文法，当且仅当对G中每个非终结符A的任何两个不同的规则$A \leftarrow \alpha | \beta$,满足：<br>$SELECT(A \rightarrow \alpha) \cap SELECT(A \rightarrow \beta) = \emptyset $<br>其中$\alpha$ 和 $\beta$不同时能$^*_\Rightarrow \epsilon$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LL-1-文法的定义&quot;&gt;&lt;a href=&quot;#LL-1-文法的定义&quot; class=&quot;headerlink&quot; title=&quot;LL(1)文法的定义&quot;&gt;&lt;/a&gt;LL(1)文法的定义&lt;/h2&gt;&lt;p&gt;一个上下文无关文法G是LL(1)文法，当且仅当对G中每个非终结符A的任何两个
      
    
    </summary>
    
    
    
      <category term="编译原理" scheme="https://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>词法分析</title>
    <link href="https://yoursite.com/2020/10/15/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>https://yoursite.com/2020/10/15/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2020-10-15T08:43:51.000Z</published>
    <updated>2021-01-19T04:31:32.997Z</updated>
    
    <content type="html"><![CDATA[<p><strong>词法分析是编译的第一个阶段，它的主要任务是从左到右逐个字符地对源程序进行扫描，产生一个个单词序列，用于语法分析。</strong><br>单词符号一般分为5类：关键字，标识符，常数，运算符，界符。</p><h2 id="正规文法"><a href="#正规文法" class="headerlink" title="正规文法"></a>正规文法</h2><p>正规文法也称三型文法$G=(V_N,V_T,S,P)$，其P中的每一条规则都有下面的形式：$A \rightarrow aB$或者$A \rightarrow a$,其中$A,B \in V_N , a \in V_T^*$关键字也是一种单词，一般关键字都是由字母构成的。</p><p>正规式又称正则表达式</p><h2 id="DFA——确定的有穷自动机"><a href="#DFA——确定的有穷自动机" class="headerlink" title="DFA——确定的有穷自动机"></a>DFA——确定的有穷自动机</h2><h2 id="NFA——不确定的有穷自动机"><a href="#NFA——不确定的有穷自动机" class="headerlink" title="NFA——不确定的有穷自动机"></a>NFA——不确定的有穷自动机</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;词法分析是编译的第一个阶段，它的主要任务是从左到右逐个字符地对源程序进行扫描，产生一个个单词序列，用于语法分析。&lt;/strong&gt;&lt;br&gt;单词符号一般分为5类：关键字，标识符，常数，运算符，界符。&lt;/p&gt;
&lt;h2 id=&quot;正规文法&quot;&gt;&lt;a href=&quot;#正规
      
    
    </summary>
    
    
    
      <category term="编译原理" scheme="https://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>人人都是产品经理读后感</title>
    <link href="https://yoursite.com/2020/10/13/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>https://yoursite.com/2020/10/13/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E8%AF%BB%E5%90%8E%E6%84%9F/</id>
    <published>2020-10-13T09:16:09.000Z</published>
    <updated>2021-01-19T04:31:32.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大三上时间也挺快的，这一晃就过了一个月了，发生的事情其实也不少，每天都被暑假自闭，综合测评，课程知识作业所干扰，有时候还出现了一些人际关系的问题，没有很沉下心去学习吧，不过好在leetcode刷题和github打卡还有更新博客的计划还是坚持了下来（虽然前天修改奖学金材料和班级体申报书断了😥，都怪dj！😡），这学期选了软件需求工程这门课，我觉得老师布置的作业和实验都十分有趣，虽然说如果要做好的话确实花一些时间，不过我还是觉得这个课程确实值得去学习和认真完成，而且也是我想要去学习的，正好布置了这样一个作业，我就当博客写写吧。</p><h2 id="人人都是产品经理读后感"><a href="#人人都是产品经理读后感" class="headerlink" title="人人都是产品经理读后感"></a>人人都是产品经理读后感</h2><p>其实说到产品经理，应该大部分的人都觉得这可能是个轻松的工作，其实我在读这本书之前我也是这么认为的，读了以后我才知道产品经理其实也是一个很考验设计和协调能力的职业，需要掌握的技能也不比技术人员简单。</p><h2 id="其实，你的灵魂深处也有一个“大卫”，而你就是自己的米开朗基罗"><a href="#其实，你的灵魂深处也有一个“大卫”，而你就是自己的米开朗基罗" class="headerlink" title="其实，你的灵魂深处也有一个“大卫”，而你就是自己的米开朗基罗"></a>其实，你的灵魂深处也有一个“大卫”，而你就是自己的米开朗基罗</h2><a id="more"></a><p>一开始我就被这句话吸引了，这也是这本书的初衷吧，人人都是产品经理，如果把每个人的一生看做一个产品，那么你已经设计了将近 20 年，一锤又一锤，在召唤着你灵魂深处的那个“大卫”——产品经理，没错，他是原先就存在的，并不是谁刻意雕琢的，所以作者一开始就表示出了每个人都有当产品经理的品质，其实我想别的专业也一样吧，主要还是事在人为，如果真的对某一样职业或者运动有自己强烈的愿望，那么不妨用你自己的方式去解读和学习将他做到极致，从而雕刻出你想要呈现的模样。</p><h2 id="人人都是产品经理-≠-人人都喜欢做产品经理"><a href="#人人都是产品经理-≠-人人都喜欢做产品经理" class="headerlink" title="人人都是产品经理 ≠ 人人都喜欢做产品经理"></a>人人都是产品经理 ≠ 人人都喜欢做产品经理</h2><p>同时作者其实谈到了一个很重要的问题，那就是自己是否真的喜欢做产品，他讲的很好：<strong>你说自己喜欢产品，到底是喜欢做用户，还是喜欢做产品经理？</strong>，作者谈到了作为用户和产品经理两者的差距，当你对一个产品感兴趣的时候，回想一下脑中萦绕的问题是站在用户的角度，还是站在产品经理的角度。</p><p>通常，用户会去想怎么用这个产品，才能带给自己更大的好处，产生更大的效用；而产品经理则习惯于绕过表象，从背后看问题的本质，思考怎么设计这个产品才能更好地平衡用户目标与商业目标。所以说这两者的区别还是很大的，作为产品经理不仅需要考虑产品的用户体验，还得在获得口碑的前提下达到商业的目标，所以说这个职业还是很难的。</p><h2 id="文档规范化处理"><a href="#文档规范化处理" class="headerlink" title="文档规范化处理"></a>文档规范化处理</h2><p>其实这一点是在我们这本书里面提到比较多的一个方面，需求获取，产品研究，然后由产品经理处理成规范详细的文档，然后交给技术人员去实现，不要小看这一步，这一步做的好的话，其实能节省很多不必要的麻烦和功能设计上的问题，减少返工的次数。<br>文档规范化处理，其实用到了很多我们上学期学到的软件工程的知识，UML建模设计，类图，用例规约，office三件套，不要小看这些内容，其实我觉得文字功底也是作为一个产品或者技术人员必备的技能。</p><p>一个好的产品经理，必然需要有很强的需求概括描述，需求可行性分析和产品修正能力，这样才能更好的和技术人员进行沟通，更高效的完成任务，<strong>同时不要以为技术人员就不必要掌握这些技能，其实这些技能对程序员也是很有用的。</strong></p><p>一个好的技术人员能够从需求中快速构建出自己的解决方案，从而写出对应的技术文档，这样才能更便于团队开发，帮助同事了解这些内容，而且成熟凝练的文字和博文，也是一种自己能力的体现，也能体现出你的技术水平，而且我也打过好几个开发比赛，大学生打比赛也经常要写技术文档，所以还是需要去了解这些方面的知识，然后把他们灵活运用到这个上面。总的来说，这一套规范其实是我们作为互联网从业人员必备的一种技能吧，也值得我们掌握。</p><h2 id="产品经理的自我修养，也是每个职业的自我修养"><a href="#产品经理的自我修养，也是每个职业的自我修养" class="headerlink" title="产品经理的自我修养，也是每个职业的自我修养"></a>产品经理的自我修养，也是每个职业的自我修养</h2><p>前面的章节主要谈论的是关于技术细节的问题，虽然这些知识和技能是我们必备的，不过相比写需求文档和产品经理的成长路线，我还是更喜欢成为一名拥有炫酷技术能力的工程师，但是在这里我更关注的是，产品经理的自我修养和调整，这个我认为不管是技术员还是产品经理，或者是其他专业，其实都是可以学习的一些生活经验吧，而且它里面提到的那几个方面，<strong>爱生活，有理想，会思考，能沟通，产品经理主义</strong>都是非常有用的。</p><p>先说<strong>爱生活</strong>好了，作为产品经理，生活经验和细节能给他带来很多的灵感，其实很多时候我们去寻找需求，就是去感受用户体验，体会生活，观察生活中的小细节，所以一个热爱生活，擅于从生活中发现奇妙，乐观积极的人会很敏锐地察觉到很多常人或者说普通用户没有感觉到的小问题。<br>正如作者所说：<br><strong>一个人只有拥有了积极、乐观、向上的人生态度，内心才会有爱，才会去积极发现生活中的美，才会有好奇心和创造力，才会愿意研究生活中的产品，才会爱上做产品这样一件改变世界的事情。</strong><br>其实其他的部门和行业也是一样，不管是什么职业，热爱生活是最重要的，如果一个人总是埋怨生活，抱怨自己遇到的各种不顺，工作上的压力，那么他肯定是不快乐的，其实这种消极的情绪很多时候会影响我们做事情的效率，尤其是对于编程这种行业，有时候真的不能急躁，一定要静下心来思考，慢慢来，一步一步踏踏实实做好。</p><p><strong>有理想</strong>这点其实对我来说的话就是有一个<strong>清晰的规划</strong>吧，这样才能使得我们在奋斗路上不会迷失方向，然后有了明确的计划和方向，我们才能更加坚定的走我们自己的道路。</p><p>其实到大三，我自己也是有一些迷茫的，虽然说目前的状况相对其他同学要好一点。不过这里先给大家提个醒，<strong>不要做很多的从0到1，要做1到100</strong>，之前做了太多的0-1的工作，其实这样是不太好了，身边的同学有一些对方向比较坚决的同学，有些已经学到了很深的水准，自己也因为比赛失误等等各种各样的原因导致自己对自己的能力开始怀疑，不过话说回来，说这些原因无非是给自己找了一些客观原因，想想自己其实还是有比较高的目标和理想的，所以慢慢的尝试和走出那些困扰就好了，<strong>正如马云说的，梦想还是要有的，万一那天就实现了呢。</strong></p><p><strong>思考和沟通</strong>，这两点其实也是我们作为技术人员比较缺乏的一点吧，其实有很多的技术员，在交流上存在一些障碍，思考的时候也经常犯一些经验性的错误，其实反观成功人士，他们在这个方面是做的很好的，说话的艺术真的很重要，不管是在我们的生活中，还是工作上，现在很多的项目都不是一个人单干能做完的任务，所以这个时候交流的作用就很重要了。</p><p>这个其实我自己也有很多体会，我也参加过各种各样的比赛，有时候虽然我们大家都觉得自己理解了对方的思路，其实有时候还是有一些偏差的，所以经常导致了接口测试的时候出现了很多的问题，而这时候如果有一个会沟通，思维能力强的产品经理，在解决这种矛盾的时候是十分得心应手的，而且能够把这种事情处理的十分合理，<strong>这就是产品经理的魅力所在，也是能力的表现。</strong></p><p>技术人员如果能掌握好这个技巧的话，就能更好的带领团队更高效的实现任务需求，其实我认为这也是一种技术人员转型做管理层和设计师的潜质，这也是我自己为什么会选择大学去当班长去锻炼这种能力的原因，<strong>从某种意义上来说，处理人与人之间的矛盾其实比修补产品bug有时候要更为重要。</strong></p><p>写到这已经差不多凌晨1点半了吧，最近真的是太累了，课程也越来越难，还有比赛，自己要学的东西，班级事务，总是想把每一件事情都安排好然后花时间去做好，但计划总赶不上变化，有时候再加上自己的一点惰性，就很难把事情处理好了，希望以后能早睡早起给，改掉这些毛病，明天又是新的开始了，希望我能继续保持作者提到的这些自我修养，然后继续前进，<strong>爱你所爱，行你所行，无问西东</strong>。</p><p><strong>附：</strong><a href="https://khany.top/file/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86.pdf" target="_blank" rel="noopener">《人人都是产品经理》的书籍下载链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大三上时间也挺快的，这一晃就过了一个月了，发生的事情其实也不少，每天都被暑假自闭，综合测评，课程知识作业所干扰，有时候还出现了一些人际关系的问题，没有很沉下心去学习吧，不过好在leetcode刷题和github打卡还有更新博客的计划还是坚持了下来（虽然前天修改奖学金材料和班级体申报书断了😥，都怪dj！😡），这学期选了软件需求工程这门课，我觉得老师布置的作业和实验都十分有趣，虽然说如果要做好的话确实花一些时间，不过我还是觉得这个课程确实值得去学习和认真完成，而且也是我想要去学习的，正好布置了这样一个作业，我就当博客写写吧。&lt;/p&gt;
&lt;h2 id=&quot;人人都是产品经理读后感&quot;&gt;&lt;a href=&quot;#人人都是产品经理读后感&quot; class=&quot;headerlink&quot; title=&quot;人人都是产品经理读后感&quot;&gt;&lt;/a&gt;人人都是产品经理读后感&lt;/h2&gt;&lt;p&gt;其实说到产品经理，应该大部分的人都觉得这可能是个轻松的工作，其实我在读这本书之前我也是这么认为的，读了以后我才知道产品经理其实也是一个很考验设计和协调能力的职业，需要掌握的技能也不比技术人员简单。&lt;/p&gt;
&lt;h2 id=&quot;其实，你的灵魂深处也有一个“大卫”，而你就是自己的米开朗基罗&quot;&gt;&lt;a href=&quot;#其实，你的灵魂深处也有一个“大卫”，而你就是自己的米开朗基罗&quot; class=&quot;headerlink&quot; title=&quot;其实，你的灵魂深处也有一个“大卫”，而你就是自己的米开朗基罗&quot;&gt;&lt;/a&gt;其实，你的灵魂深处也有一个“大卫”，而你就是自己的米开朗基罗&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="youth" scheme="https://yoursite.com/tags/youth/"/>
    
  </entry>
  
  <entry>
    <title>js——原型与原型链</title>
    <link href="https://yoursite.com/2020/10/09/js%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://yoursite.com/2020/10/09/js%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-10-09T00:39:36.000Z</published>
    <updated>2021-01-19T04:31:34.486Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>中断异常与系统调用</title>
    <link href="https://yoursite.com/2020/10/03/%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://yoursite.com/2020/10/03/%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</id>
    <published>2020-10-03T14:51:56.000Z</published>
    <updated>2021-01-19T04:31:32.120Z</updated>
    
    <content type="html"><![CDATA[<p>通常操作系统提供的主要功能都是由内核程序实现的，处理机在运行上层程序时，能进入操作系统内核运行的<strong>唯一途径</strong>就是中断或者异常。</p><h2 id="中断和异常基本概念"><a href="#中断和异常基本概念" class="headerlink" title="中断和异常基本概念"></a>中断和异常基本概念</h2><p>中断(Interruption)：也称外中断，指来自处理机执行指令以外的事件发生。<br>异常(Exception)：也称内中断、例外、自陷(trap),指源自处理机执行指令内部的事件。</p><a id="more"></a><p>常见中断类型：<br>中断：I/O中断，时钟中断。<br>异常：系统调用（具体指系统调用当中的自陷指令），缺页异常，断点指令，其他程序性异常（如：算术溢出）</p><p>中断: 与正执行指令无关，可以屏蔽；<br>异常: 与正执行指令有关，不可屏蔽</p><p>中断屏蔽：指禁止处理机响应中断或禁止中断出现.<br>中断屏蔽有两种方法:<br>1.硬件实现(由软件置处理机优先级,硬件按系统设计时的约定,屏蔽那些低优先级中断);<br>2.软件实现(由软件按操作系统优先级约定,设置屏蔽寄存器)。<br><img src="https://img-blog.csdnimg.cn/20201003231734304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201003222007777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用：操作系统内核程序和用户态运行程序之间的接口。<br>凡是涉及操作系统核心管理资源的操作必须由系统调用实现。<br><img src="https://img-blog.csdnimg.cn/20201003222258334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>1.主要系统调用<br>进程管理:</p><ul><li>创建进程   pid=fork( )</li><li>终止进程   exit(status)</li><li>等待子进程结束  pid=waitpid(pid,…)</li><li>替换进程映像  s=execve(name,…)</li></ul><p>文件管理:</p><ul><li>创建文件 fd=creat(name,…)</li><li>打开文件 fd=open(name,…)</li><li>读文件  n=read(fd,buffer,nbyte)</li><li>写文件 n=write(fd,buffer,nbyte)</li><li>移动文件指针 pos=lseek(fd,offset,…)</li><li>关闭文件 s=close(fd)</li></ul><p>存储管理：动态申请/释放存储空间等；<br>其他：设置/获得时间等。</p><p>2.自陷指令(trap)<br>系统调用是一种特殊形式的转子程序方法,它导致处理机态的变化,为了方便编程，一般提供系统调用库，由其中的子程序来组织系统调用,用户程序调系统调用库的子程序。<br>参数传递的一般形式如下：<br>1）用寄存器传递参数。<br>2）Trap指令自带参数。Trap指令是一条长指令,内核通过断点pc值加偏移获得参数。</p><p><img src="https://img-blog.csdnimg.cn/20201003222258334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201003224710968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常操作系统提供的主要功能都是由内核程序实现的，处理机在运行上层程序时，能进入操作系统内核运行的&lt;strong&gt;唯一途径&lt;/strong&gt;就是中断或者异常。&lt;/p&gt;
&lt;h2 id=&quot;中断和异常基本概念&quot;&gt;&lt;a href=&quot;#中断和异常基本概念&quot; class=&quot;headerlink&quot; title=&quot;中断和异常基本概念&quot;&gt;&lt;/a&gt;中断和异常基本概念&lt;/h2&gt;&lt;p&gt;中断(Interruption)：也称外中断，指来自处理机执行指令以外的事件发生。&lt;br&gt;异常(Exception)：也称内中断、例外、自陷(trap),指源自处理机执行指令内部的事件。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的运行机制和体系结构</title>
    <link href="https://yoursite.com/2020/10/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://yoursite.com/2020/10/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-10-03T13:37:16.000Z</published>
    <updated>2021-01-19T04:31:33.168Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统比较硬核，不过最近发现了<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=6" target="_blank" rel="noopener">王道考研</a>这个比较好的课程。这里是一些学习笔记总结。</p><a id="more"></a><h2 id="主要功能模块"><a href="#主要功能模块" class="headerlink" title="主要功能模块"></a>主要功能模块</h2><p>操作系统核心的主要功能模块介绍如下：<br><strong>系统初始化模块</strong>：准备系统运行环境，最后为每个终端创建一个进程，运行命令解释程序。</p><p><strong>进程管理模块</strong>：处理进程类系统调用（如进程创建/结束等）和进程调度。</p><p><strong>存储管理模块</strong>：配合进程管理，分配进程空间；处理存储类系统调用（如动态增加进程空间）；在虚存系统缺页异常时调入页面进行处理。</p><p><strong>文件管理模块</strong>：处理文件类系统调用。</p><p><strong>外设管理模块</strong>：负责外设驱动和中断处理。</p><h2 id="两种处理机状态"><a href="#两种处理机状态" class="headerlink" title="两种处理机状态"></a>两种处理机状态</h2><p>处理机的运行状态分为核心态（管态）和用户态（目态），我们使用处理机状态字（简称PS或者PSW）寄存器内设置一个标志位，根据祺当前值为1或0表示处理机处于核心态或者用户态。<br>管态：允许特权指令执行的状态，由此状态下地址空间也比较大。<br><img src="https://img-blog.csdnimg.cn/20201003213936235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="2"></p><h2 id="两者指令"><a href="#两者指令" class="headerlink" title="两者指令"></a>两者指令</h2><p>特权指令不允许在用户态下执行。<br>特权指令的功能：</p><ol><li>允许和禁止中断</li><li>在进程之间切换处理</li><li>存取用于内存保护的寄存器</li><li>执行I/O操作</li><li>停止一个中央处理机的工作<br><img src="https://img-blog.csdnimg.cn/20201003214212924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="1"></li></ol><h2 id="两种程序"><a href="#两种程序" class="headerlink" title="两种程序"></a>两种程序</h2><p><img src="https://img-blog.csdnimg.cn/20201003214352505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="3"></p><h2 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a>操作系统的内核</h2><p><strong>内核</strong>是计算机上配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是<strong>内核程序</strong>。<br>这里其实还确实了一种，我们常说的操作系统四大模块是指，<strong>进程管理，存储管理，设备管理和文件系统管理。</strong><br><img src="https://img-blog.csdnimg.cn/20201003214807141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="4"><br>由此引出了我们操作系统的两种内核：<strong>大内核和微内核。</strong></p><table><thead><tr><th align="center">大内核</th><th align="center">微内核</th></tr></thead><tbody><tr><td align="center">将操作系统的主要功能都作为系统内核，运行在核心态</td><td align="center">只把最基本的功能保留</td></tr><tr><td align="center">优点：高性能</td><td align="center">优点：内核功能少，结构清晰，方便维护</td></tr><tr><td align="center">缺点：内核代码庞大，结构混乱，难以维护</td><td align="center">缺点：需要频繁地在用户态和核心态之间切换，性能低</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20201003215121301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统比较硬核，不过最近发现了&lt;a href=&quot;https://www.bilibili.com/video/BV1YE411D7nH?p=6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;王道考研&lt;/a&gt;这个比较好的课程。这里是一些学习笔记总结。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>js基础——关于对象</title>
    <link href="https://yoursite.com/2020/10/02/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://yoursite.com/2020/10/02/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-10-02T08:03:30.000Z</published>
    <updated>2021-01-19T04:31:34.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象与属性"><a href="#对象与属性" class="headerlink" title="对象与属性"></a>对象与属性</h2><p>同其他语言里面所描述的对象一样，在js里，一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为方法。一个对象的属性可以被解释成一个附加到对象上的变量。对象有时也被叫作<strong>关联数组</strong>, 因为每个属性都有一个用于访问它的<strong>字符串值</strong>。</p><a id="more"></a><p>属性的访问设置与修改主要是通过两种手段实现，一种是通过点号对变量进行调用，一种是通过方括号的方式访问，其中通过方括号的方式是一种动态判定法(属性名只有到运行时才能判定)。</p><p>一个对象的属性名可以是任何有效的 JavaScript 字符串，或者可以被转换为字符串的任何类型，<strong>包括空字符串</strong>。然而，一个属性的名称如果不是一个有效的 JavaScript 标识符（例如，一个由空格或连字符，或者以数字开头的属性名），<strong>就只能通过方括号标记访问。</strong></p><p>方括号中的所有键都将转换为字符串类型，因为JavaScript中的对象只能使用<code>String</code>类型作为键类型,如果是<code>object</code>类型的话，也可以通过方括号直接添加属性，不过他添加属性的时候会调用<code>toString()</code>方法，并将其作为新的key值。</p><p>你可以在<code>for...in</code>语句中使用方括号标记以枚举一个对象的所有属性</p><p><strong>拓展</strong>：从 ECMAScript 5 开始，有三种原生的方法用于列出或枚举对象的属性：</p><ul><li><strong>for…in循环</strong><br>该方法依次访问一个对象及其原型链中所有可枚举的属性。</li><li><strong>Object.keys(o)</strong><br>该方法返回对象 o 自身包含（不包括原型中）的所有可枚举属性的名称的数组。</li><li><strong>Object.getOwnPropertyNames(o)</strong><br>该方法返回对象 o 自身包含（不包括原型中）的所有属性(无论是否可枚举)的名称的数组。</li></ul><h2 id="创建新对象"><a href="#创建新对象" class="headerlink" title="创建新对象"></a>创建新对象</h2><p>JavaScript 拥有一系列预定义的对象，当然我们也可以自己创建对象，从  JavaScript 1.2 之后，你可以通过<strong>对象初始化器</strong>（Object Initializer）创建对象。或者你可以创建一个<strong>构造函数</strong>并使用该函数和<code>new</code>操作符初始化对象。</p><h4 id="使用对象初始化器"><a href="#使用对象初始化器" class="headerlink" title="使用对象初始化器"></a>使用对象初始化器</h4><p>使用对象初始化器也被称作通过字面值创建对象，通过对象初始化器创建对象的语法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">property_1</span>:   value_1,   <span class="hljs-comment">// property_# 可以是一个标识符...</span><br>            <span class="hljs-number">2</span>:            value_2,   <span class="hljs-comment">// 或一个数字...</span><br>           [<span class="hljs-string">"property"</span> +<span class="hljs-number">3</span>]: value_3,  <span class="hljs-comment">//  或一个可计算的key名... </span><br>            <span class="hljs-comment">// ...,</span><br>            <span class="hljs-string">"property n"</span>: value_n &#125;; <span class="hljs-comment">// 或一个字符串</span><br></code></pre></td></tr></table></figure><p>这里 <code>obj</code>是新对象的名称，每一个 <code>property_i</code> 是一个标识符（可以是一个名称、数字或字符串字面量），并且每个 <code>value_i</code> 是一个其值将被赋予 <code>property_i</code> 的表达式。<strong>obj 与赋值是可选的</strong>；</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myHonda = &#123;<span class="hljs-attr">color</span>: <span class="hljs-string">"red"</span>, <span class="hljs-attr">wheels</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">engine</span>: &#123;<span class="hljs-attr">cylinders</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">2.2</span>&#125;&#125;;<span class="hljs-comment">//这里面的engine也是一个对象</span><br></code></pre></td></tr></table></figure><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><p>使用构造函数实例化对象的过程分为两步：</p><ol><li>通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。</li><li>通过 <code>new</code> 创建对象实例。</li></ol><h4 id="使用-Object-create-方法"><a href="#使用-Object-create-方法" class="headerlink" title="使用 Object.create 方法"></a>使用 Object.create 方法</h4><p>对象也可以用 <code>Object.create()</code> 方法创建。该方法非常有用，因为它允许你为创建的对象选择一个原型对象，而不用定义构造函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Animal properties and method encapsulation</span><br><span class="hljs-keyword">var</span> Animal = &#123;<br>  type: <span class="hljs-string">"Invertebrates"</span>, <span class="hljs-comment">// 属性默认值</span><br>  displayType : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 用于显示type属性的方法</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.type);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建一种新的动物——animal1 </span><br><span class="hljs-keyword">var</span> animal1 = <span class="hljs-built_in">Object</span>.create(Animal);<br>animal1.displayType(); <span class="hljs-comment">// Output:Invertebrates</span><br><br><span class="hljs-comment">// 创建一种新的动物——Fishes</span><br><span class="hljs-keyword">var</span> fish = <span class="hljs-built_in">Object</span>.create(Animal);<br>fish.type = <span class="hljs-string">"Fishes"</span>;<br>fish.displayType(); <span class="hljs-comment">// Output:Fishes</span><br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>所有的 JavaScript 对象至少继承于一个对象。<strong>被继承的对象被称作原型，并且继承的属性可通过构造函数的<code>prototype</code>对象找到。</strong></p><h2 id="为对象类型定义属性"><a href="#为对象类型定义属性" class="headerlink" title="为对象类型定义属性"></a>为对象类型定义属性</h2><p>你可以通过 prototype 属性为之前定义的对象类型增加属性。这为该类型的所有对象，而不是仅仅一个对象增加了一个属性。下面的代码为所有类型为 car 的对象增加了 color 属性，然后为对象 car1 的 color 属性赋值：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">Car.prototype.color = <span class="hljs-literal">null</span>;<br>car1.color = <span class="hljs-string">"black"</span>;<br></code></pre></td></tr></table></figure><h2 id="通过-this-引用对象"><a href="#通过-this-引用对象" class="headerlink" title="通过 this 引用对象"></a>通过 this 引用对象</h2><p>avaScript 有一个特殊的关键字 this，它可以在方法中使用以指代当前对象。</p><h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p>你可以用<code>delete</code>操作符删除一个<strong>不是继承而来</strong>的属性。下面的例子说明如何删除一个属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//Creates a new object, myobj, with two properties, a and b.</span><br><span class="hljs-keyword">var</span> myobj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;<br>myobj.a = <span class="hljs-number">5</span>;<br>myobj.b = <span class="hljs-number">12</span>;<br><br><span class="hljs-comment">//Removes the a property, leaving myobj with only the b property.</span><br><span class="hljs-keyword">delete</span> myobj.a;<br></code></pre></td></tr></table></figure><h2 id="比较对象"><a href="#比较对象" class="headerlink" title="比较对象"></a>比较对象</h2><p><strong>在 JavaScript 中 objects 是一种引用类型。两个独立声明的对象永远也不会相等，即使他们有相同的属性，只有在比较一个对象和这个对象的引用时，才会返回true.</strong><br>这边是官方给出的例子</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 两个变量, 两个具有同样的属性、但不相同的对象</span><br><span class="hljs-keyword">var</span> fruit = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"apple"</span>&#125;;<br><span class="hljs-keyword">var</span> fruitbear = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"apple"</span>&#125;;<br><br>fruit == fruitbear <span class="hljs-comment">// return false</span><br>fruit === fruitbear <span class="hljs-comment">// return false</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 两个变量, 同一个对象</span><br><span class="hljs-keyword">var</span> fruit = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">"apple"</span>&#125;;<br><span class="hljs-keyword">var</span> fruitbear = fruit;  <span class="hljs-comment">// 将fruit的对象引用(reference)赋值给 fruitbear</span><br>                        <span class="hljs-comment">// 也称为将fruitbear“指向”fruit对象</span><br><span class="hljs-comment">// fruit与fruitbear都指向同样的对象</span><br>fruit == fruitbear <span class="hljs-comment">// return true</span><br>fruit === fruitbear <span class="hljs-comment">// return true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象与属性&quot;&gt;&lt;a href=&quot;#对象与属性&quot; class=&quot;headerlink&quot; title=&quot;对象与属性&quot;&gt;&lt;/a&gt;对象与属性&lt;/h2&gt;&lt;p&gt;同其他语言里面所描述的对象一样，在js里，一个对象就是一系列属性的集合，一个属性包含一个名和一个值。一个属性的值可以是函数，这种情况下属性也被称为方法。一个对象的属性可以被解释成一个附加到对象上的变量。对象有时也被叫作&lt;strong&gt;关联数组&lt;/strong&gt;, 因为每个属性都有一个用于访问它的&lt;strong&gt;字符串值&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web基础" scheme="https://yoursite.com/tags/web%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>编译原理第二章——文法分类</title>
    <link href="https://yoursite.com/2020/10/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94%E6%96%87%E6%B3%95%E5%88%86%E7%B1%BB/"/>
    <id>https://yoursite.com/2020/10/02/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94%E6%96%87%E6%B3%95%E5%88%86%E7%B1%BB/</id>
    <published>2020-10-02T01:35:22.000Z</published>
    <updated>2021-01-19T04:31:33.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语言和文法"><a href="#语言和文法" class="headerlink" title="语言和文法"></a>语言和文法</h1><p>编译原理第二章文法分类，紫书内容和mooc知识总结，重新回顾了4种文法的知识。</p><h2 id="文法分类"><a href="#文法分类" class="headerlink" title="文法分类"></a>文法分类</h2><p>乔姆斯基把语言文法分成4类，0型，1型，2型，3型，这几类文法的差别主要在于对产生式的限制不同，等级越高，限制越严格。</p><h4 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h4><p>0型文法是文法限制最弱的一种类型，0型文法的能力又被相当于<strong>图灵机</strong>模型，或者说<strong>任何0型文法都是递归可枚举的，反之，递归可枚举的一定是一个0型语言</strong>。</p><a id="more"></a><p><strong>定义：</strong><br>设$G=(V_N,V_T,P,S)$，如果$P$中的每一个产生式$\alpha$-&gt;$\beta$满足条件：</p><ol><li>$\alpha \in (V_N \cup V_T)^*$且至少含有一个非终结符。</li><li>$\beta \in (V_N \cup V_T)^*$</li></ol><p><strong>0型例子：</strong><br><img src="https://img-blog.csdnimg.cn/20201002110133143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="0型实例"></p><h4 id="1型文法——上下文有关文法"><a href="#1型文法——上下文有关文法" class="headerlink" title="1型文法——上下文有关文法"></a>1型文法——上下文有关文法</h4><p>1型文法中最主要的限制条件主要是对于产生式P均满足$|\beta| \ge|\alpha|$,仅$S \rightarrow \epsilon$除外。<br><strong>等价定义：</strong><br><img src="https://img-blog.csdnimg.cn/20201002111340975.png#pic_center" alt="1型文法"></p><p><strong>1型例子：</strong><br><img src="https://img-blog.csdnimg.cn/20201002111557799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="1型文法"></p><h4 id="2型文法——上下文无关文法"><a href="#2型文法——上下文无关文法" class="headerlink" title="2型文法——上下文无关文法"></a>2型文法——上下文无关文法</h4><p>2型文法对应的是<strong>下推自动机</strong>模型，常用于描述高级语言的<strong>语法规则</strong>。<br><strong>定义：</strong><br>设$G=(V_N,V_T,P,S)$，如果$P$中的每一个产生式$\alpha$-&gt;$\beta$满足条件：</p><ol><li>$\alpha$是<strong>一个</strong>非终结符。</li><li>$\beta \in (V_N \cup V_T)^*$</li></ol><p><strong>2型例子：</strong><br><img src="https://img-blog.csdnimg.cn/20201002141025946.png#pic_center" alt="在这里插入图片描述"></p><h4 id="3型文法——正规文法"><a href="#3型文法——正规文法" class="headerlink" title="3型文法——正规文法"></a>3型文法——正规文法</h4><p>正规文法对应的是有穷自动机，用来描述高级语言的<strong>词法规则</strong><br><strong>定义：</strong><br>设$G=(V_N,V_T,P,S)$，如果$P$中的每一个产生式$\alpha$-&gt;$\beta$都是$A-&gt;aB$或者$A-&gt;a$的形式，其中A，B都是非终结符，$a \in V_T^*$即就是，由一个非终结符推导出一个终结符或者一个终结符+一个非终结符构成的字串。</p><p><img src="https://img-blog.csdnimg.cn/20201002142059138.png#pic_center" alt="3"></p><p><strong>正规文法例子：</strong><br>这里尖括号括起来的是非终结符，其他的是终结符。<br><img src="https://img-blog.csdnimg.cn/20201002142509302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="3"></p><p>4种文法的定义的限制是逐步增强的，四种文法是逐步包含的，因此每一种正规文法都是上下文无关的，每一种上下文无关文法都是上下文有关的，每一种上下文有关文法都是0型文法。</p><p><img src="https://img-blog.csdnimg.cn/20201002142911916.png#pic_center" alt="0"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;语言和文法&quot;&gt;&lt;a href=&quot;#语言和文法&quot; class=&quot;headerlink&quot; title=&quot;语言和文法&quot;&gt;&lt;/a&gt;语言和文法&lt;/h1&gt;&lt;p&gt;编译原理第二章文法分类，紫书内容和mooc知识总结，重新回顾了4种文法的知识。&lt;/p&gt;
&lt;h2 id=&quot;文法分类&quot;&gt;&lt;a href=&quot;#文法分类&quot; class=&quot;headerlink&quot; title=&quot;文法分类&quot;&gt;&lt;/a&gt;文法分类&lt;/h2&gt;&lt;p&gt;乔姆斯基把语言文法分成4类，0型，1型，2型，3型，这几类文法的差别主要在于对产生式的限制不同，等级越高，限制越严格。&lt;/p&gt;
&lt;h4 id=&quot;0型文法&quot;&gt;&lt;a href=&quot;#0型文法&quot; class=&quot;headerlink&quot; title=&quot;0型文法&quot;&gt;&lt;/a&gt;0型文法&lt;/h4&gt;&lt;p&gt;0型文法是文法限制最弱的一种类型，0型文法的能力又被相当于&lt;strong&gt;图灵机&lt;/strong&gt;模型，或者说&lt;strong&gt;任何0型文法都是递归可枚举的，反之，递归可枚举的一定是一个0型语言&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="编译原理" scheme="https://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句————数据查询</title>
    <link href="https://yoursite.com/2020/09/30/SQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>https://yoursite.com/2020/09/30/SQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-09-29T16:08:03.000Z</published>
    <updated>2021-01-19T04:31:33.654Z</updated>
    
    <content type="html"><![CDATA[<p>数据查询是数据库最核心的功能，也是我们需要重点掌握的部分，该语句有很多灵活多变的操作值得我们去学习。<br>其一般格式为：（一般格式写的比较复杂，但一般不会这么复杂）</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span>|<span class="hljs-keyword">DISTINCT</span>] &lt;目标列表达式&gt; [,&lt;目标列表达式&gt;] ...<br><span class="hljs-keyword">FROM</span> &lt;表名或者视图名&gt; [,&lt;表名或者视图名&gt;...] | (&lt;<span class="hljs-keyword">SELECT</span> 语句&gt; 嵌套) [<span class="hljs-keyword">AS</span>] &lt;别名&gt;<br><span class="hljs-keyword">WHERE</span> &lt;条件表达式&gt; | (&lt;<span class="hljs-keyword">SELECT</span> 语句&gt; 嵌套) <br>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> &lt;列名<span class="hljs-number">1</span>&gt; [<span class="hljs-keyword">HAVING</span> &lt;条件表达式&gt;]]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &lt;列名<span class="hljs-number">2</span>&gt; [,&lt;列名<span class="hljs-number">3</span>&gt;...] [<span class="hljs-keyword">ASC</span>(升序)|<span class="hljs-keyword">DESC</span>(降序)] ];<br></code></pre></td></tr></table></figure><!--mroe-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据查询是数据库最核心的功能，也是我们需要重点掌握的部分，该语句有很多灵活多变的操作值得我们去学习。&lt;br&gt;其一般格式为：（一般格式写的比较复杂，但一般不会这么复杂）&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
    
      <category term="数据库系统" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句————数据定义</title>
    <link href="https://yoursite.com/2020/09/29/SQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/"/>
    <id>https://yoursite.com/2020/09/29/SQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</id>
    <published>2020-09-29T15:38:18.000Z</published>
    <updated>2021-01-19T04:31:33.636Z</updated>
    
    <content type="html"><![CDATA[<p>SQL又称结构化查询语句（Structed Query Language）是关系数据库的标准语言，也是一个通用的，功能极强的关系数据库语言。<br>SQL集<strong>数据查询、数据操纵、数据定义、数据控制</strong>功能于一体。<br><strong>目前没有一个数据库系统能支持SQL标准的所有概念和特性。但同时许多软件厂商对SQL基本命令集还进行了不同程度的扩充和修改，又可以支持标准以外的一些功能特性。</strong></p><a id="more"></a><h2 id="定义模式"><a href="#定义模式" class="headerlink" title="定义模式"></a>定义模式</h2><p>在SQL中，模式定义语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">SCHEMA</span> &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;<br></code></pre></td></tr></table></figure><p>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;<br>要创建模式，调用该命令的用户名必需拥有数据库管理员权限，或者获得了数据库管理员授权的CREATE SCHEMA的权限。</p><h2 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">SCHEMA</span> &lt;模式名&gt; &lt;<span class="hljs-keyword">CASCADE</span>|RESTRICT&gt;<br></code></pre></td></tr></table></figure><p>其中CASCADE|RESTRICT必须二选一，两者有不同的作用。</p><ol><li>CASCADE，级联，表示在删除模式的同时把该模式中所有的数据库对象全部删除。</li><li>选择了RESTRICT，限制，表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行。</li></ol><h2 id="基本表的定义与创建"><a href="#基本表的定义与创建" class="headerlink" title="基本表的定义与创建"></a>基本表的定义与创建</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> &lt;表名&gt;(<br>    &lt;列名&gt;&lt;数据类型&gt;,[列级完整性约束条件],<br>    &lt;列名&gt;&lt;数据类型&gt;,[列级完整性约束条件],<br>    &lt;列名&gt;&lt;数据类型&gt;,[列级完整性约束条件],<br>    ...<br>);<br></code></pre></td></tr></table></figure><h2 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h2><p>修改语句主要是通过ALERT TABLE来操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> &lt;表名&gt;<br>[<span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">COLUMN</span>] &lt;新列名&gt;&lt;数据类型&gt; [完整性约束]]<br>[<span class="hljs-keyword">ADD</span> &lt;表级完整性约束&gt;]<br>[<span class="hljs-keyword">DROP</span> [<span class="hljs-keyword">COLUMN</span>] &lt;列名&gt; [<span class="hljs-keyword">CASCADE</span>|RESTRICT] ]<br>[<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> &lt;完整性约束名&gt; [<span class="hljs-keyword">CASCADE</span>|RESTRICT]]<br>[ALER <span class="hljs-keyword">COLUMN</span>&lt;列名&gt;&lt;数据类型&gt;];<br></code></pre></td></tr></table></figure><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> &lt;表名&gt; [RESTRICT|<span class="hljs-keyword">CASCADE</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL又称结构化查询语句（Structed Query Language）是关系数据库的标准语言，也是一个通用的，功能极强的关系数据库语言。&lt;br&gt;SQL集&lt;strong&gt;数据查询、数据操纵、数据定义、数据控制&lt;/strong&gt;功能于一体。&lt;br&gt;&lt;strong&gt;目前没有一个数据库系统能支持SQL标准的所有概念和特性。但同时许多软件厂商对SQL基本命令集还进行了不同程度的扩充和修改，又可以支持标准以外的一些功能特性。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库系统" scheme="https://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>js基础——数组对象(Array object)</title>
    <link href="https://yoursite.com/2020/09/29/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1-Array-object/"/>
    <id>https://yoursite.com/2020/09/29/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1-Array-object/</id>
    <published>2020-09-29T12:11:24.000Z</published>
    <updated>2021-01-19T04:31:34.095Z</updated>
    
    <content type="html"><![CDATA[<p>这次要介绍的是js的数组对象，其实在js里面他本质上是一种object对象（他的原型），创建和使用方法和python有点类似,最重要的一点数组里面的数据类型可以是各种类型。</p><a id="more"></a><h2 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h2><p>使用<code>Array()</code>的方式或者直接用<code>[]</code>来创建一个数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(element0, element1, ..., elementN);<br><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>(element0, element1, ..., elementN);<br><span class="hljs-keyword">var</span> arr = [element0, element1, ..., elementN];<br><br><span class="hljs-comment">// 译者注: var arr=[4] 和 var arr=new Array(4)是不等效的，</span><br><span class="hljs-comment">// 后者4指数组长度，所以使用字面值(literal)的方式应该不仅仅是便捷，同时也不易踩坑</span><br></code></pre></td></tr></table></figure><p>为了创建一个长度不为0，但是又没有任何元素的数组，可选以下任何一种方式：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(arrayLength);<br><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>(arrayLength);<br><br><span class="hljs-comment">// 这样有同样的效果</span><br><span class="hljs-keyword">var</span> arr = [];<br>arr.length = arrayLength;<br></code></pre></td></tr></table></figure><p>这里还有一些特殊情况需要进行说明</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a=[,<span class="hljs-string">"12"</span>,,<span class="hljs-number">3</span>];<span class="hljs-comment">//这样的数组也是成立的，这种逗号法省略的部分为undefined</span><br><span class="hljs-keyword">let</span> b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,,];<span class="hljs-comment">//这里数组最后一个逗号是忽略的，也就是这里只有一个undefined</span><br></code></pre></td></tr></table></figure><p>结果测试：<br><img src="/2020/09/29/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1-Array-object/1.png" alt="测试结果"></p><h2 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a>填充数组</h2><p>可以使用类似赋值操作的方法来填充元素，如果你在以上代码中给数组操作符的是一个<strong>非整形数值</strong>，那么将作为一个代表数组的对象的属性(property)创建，而非作为数组的元素。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> emp = [];<br>emp[<span class="hljs-number">0</span>] = <span class="hljs-string">"Casey Jones"</span>;<br>emp[<span class="hljs-number">1</span>] = <span class="hljs-string">"Phil Lesh"</span>;<br>emp[<span class="hljs-number">2</span>] = <span class="hljs-string">"August West"</span>;<br></code></pre></td></tr></table></figure><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>关于数组的方法其实很多，这里我们不会一一详细介绍，大概就给一些常用的函数。<br><code>concat()</code> 连接两个数组并返回一个新的数组。<br><code>join(deliminator = &#39;,&#39;)</code> 将数组的所有元素连接成一个字符串。<br><code>push()</code> 在数组末尾添加一个或多个元素，并返回数组操作后的长度。<br><code>sort()</code> 给数组元素排序。<br><code>pop()</code> 从数组移出最后一个元素，并返回该元素。<br><code>slice(start_index, upto_index)</code> 从数组提取一个片段，并作为一个新数组返回。</p><p><code>map(callback[, thisObject])</code> 在数组的每个单元项上执行<code>callback</code>函数，并把返回包含回调函数返回值的新数组（译者注：也就是遍历数组，并通过callback对数组元素进行操作，并将所有操作结果放入数组中并返回该数组）。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];<br><span class="hljs-keyword">var</span> a2 = a1.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123; <span class="hljs-keyword">return</span> item.toUpperCase(); &#125;);<br><span class="hljs-built_in">console</span>.log(a2); <span class="hljs-comment">// logs A,B,C</span><br></code></pre></td></tr></table></figure><p><code>filter(callback[, thisObject])</code> 返回一个包含所有在回调函数上返回为true的元素的新数组（译者注：callback在这里担任的是过滤器的角色，当元素符合条件，过滤器就返回true，而filter则会返回所有符合过滤条件的元素）。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a1 = [<span class="hljs-string">'a'</span>, <span class="hljs-number">10</span>, <span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>, <span class="hljs-string">'c'</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">var</span> a2 = a1.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> item == <span class="hljs-string">'number'</span>; &#125;);<br><span class="hljs-built_in">console</span>.log(a2); <span class="hljs-comment">// logs 10,20,30</span><br></code></pre></td></tr></table></figure><p><code>every(callback[, thisObject])</code> 当数组中每一个元素在<code>callback</code>上被返回true时就返回true（译者注：同上，every其实类似<code>filter</code>，只不过它的功能是判断是不是数组中的所有元素都符合条件，并且返回的是布尔值）。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">value</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'number'</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(a1.every(isNumber)); <span class="hljs-comment">// logs true</span><br><span class="hljs-keyword">var</span> a2 = [<span class="hljs-number">1</span>, <span class="hljs-string">'2'</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(a2.every(isNumber)); <span class="hljs-comment">// logs false</span><br></code></pre></td></tr></table></figure><p><code>some(callback[, thisObject])</code> 只要数组中有一项在callback上被返回true，就返回true（译者注：同上，类似every，不过前者要求都符合筛选条件才返回true，后者只要有符合条件的就返回true）。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">value</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'number'</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(a1.some(isNumber)); <span class="hljs-comment">// logs true</span><br><span class="hljs-keyword">var</span> a2 = [<span class="hljs-number">1</span>, <span class="hljs-string">'2'</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.log(a2.some(isNumber)); <span class="hljs-comment">// logs true</span><br><span class="hljs-keyword">var</span> a3 = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>];<br><span class="hljs-built_in">console</span>.log(a3.some(isNumber)); <span class="hljs-comment">// logs false</span><br></code></pre></td></tr></table></figure><h2 id="数组推导式"><a href="#数组推导式" class="headerlink" title="数组推导式"></a>数组推导式</h2><p>这个其实有点类似于python里面的列表推导式或者列表条件筛选操作，主要还是对上面的map()和filter()做了一些改进吧，让他的使用更方便了。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> doubled = [<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">of</span> numbers) i * <span class="hljs-number">2</span>];<br><span class="hljs-built_in">console</span>.log(doubled); <span class="hljs-comment">// logs 2,4,6,8</span><br></code></pre></td></tr></table></figure><p>这种方法等价于map函数</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> doubled = numbers.map(fuction(i)&#123;<span class="hljs-keyword">return</span> i*<span class="hljs-number">2</span>&#125;;);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">var</span> evens = [i <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">of</span> numbers) <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)];<br><span class="hljs-built_in">console</span>.log(evens); <span class="hljs-comment">// logs 2,22,30</span><br></code></pre></td></tr></table></figure><p>这种方法等价于filter函数</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events=numbers.filter(fuction(i)&#123;<span class="hljs-keyword">return</span> i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次要介绍的是js的数组对象，其实在js里面他本质上是一种object对象（他的原型），创建和使用方法和python有点类似,最重要的一点数组里面的数据类型可以是各种类型。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web基础" scheme="https://yoursite.com/tags/web%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js基础——函数</title>
    <link href="https://yoursite.com/2020/09/27/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/"/>
    <id>https://yoursite.com/2020/09/27/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</id>
    <published>2020-09-27T07:55:13.000Z</published>
    <updated>2021-01-19T04:31:34.458Z</updated>
    
    <content type="html"><![CDATA[<p>这一块关于闭包和箭头函数理解还不够，先提交一点记录一下，后期再补</p><a id="more"></a><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>一个函数定义（也称为函数声明，或函数语句）由一系列的function关键字组成，依次为：</p><ol><li>函数的名称。</li><li>函数参数列表，包围在括号中并由逗号分隔。</li><li>定义函数的 JavaScript 语句，用大括号<code>{}</code>括起来。</li></ol><p><strong>当函数参数为基本类型时，则会采用值传递的方式，不会改变变量本身，而当你传递的是一个对象（即一个非原始值，例如<code>Array</code>或用户自定义的对象）作为参数的时候，而函数改变了这个对象的属性，这样的改变对函数外部是可见的</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">theObject</span>) </span>&#123;<br>  theObject.make = <span class="hljs-string">"Toyota"</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> mycar = &#123;<span class="hljs-attr">make</span>: <span class="hljs-string">"Honda"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Accord"</span>, <span class="hljs-attr">year</span>: <span class="hljs-number">1998</span>&#125;;<br><span class="hljs-keyword">var</span> x, y;<br><br>x = mycar.make;     <span class="hljs-comment">// x获取的值为 "Honda"</span><br><br>myFunc(mycar);<br>y = mycar.make;<br></code></pre></td></tr></table></figure><h2 id="函数表达式——Function-expressions"><a href="#函数表达式——Function-expressions" class="headerlink" title="函数表达式——Function expressions"></a>函数表达式——Function expressions</h2><p>根据MDN的文档描述我大致理解了他所说的函数表达式用法和意义了，其实类似于c语言的函数指针和java匿名函数相结合的这种用法，这种用法的最大好处就是能够将函数作为一个参数或者变量，将其传递给其他的函数使用</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数主要利用的是箭头表达式，箭头函数表达式的语法比函数表达式更简洁，箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。<strong>箭头函数两大特点：更简短的函数并且不绑定this。</strong><br>箭头函数真的很灵活，我暂时还没法完全参透只是了解了一个大概，具体的用法可以去MDN上看官方文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一块关于闭包和箭头函数理解还不够，先提交一点记录一下，后期再补&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web基础" scheme="https://yoursite.com/tags/web%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>js基础——数据类型与基本逻辑语句</title>
    <link href="https://yoursite.com/2020/09/26/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/"/>
    <id>https://yoursite.com/2020/09/26/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-09-26T07:57:00.000Z</published>
    <updated>2021-01-19T04:31:34.199Z</updated>
    
    <content type="html"><![CDATA[<p>本文将记录学习JavaScript(包含有ES)语法基础,主要来自<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank" rel="noopener">MDN</a>的官方文档</p><a id="more"></a><h2 id="语法和数据类型"><a href="#语法和数据类型" class="headerlink" title="语法和数据类型"></a>语法和数据类型</h2><p>最新的 ECMAScript 标准定义了8种数据类型：</p><ul><li>七种基本数据类型:</li></ul><ol><li>布尔值（<code>Boolean</code>），有2个值分别是：true 和 false.</li><li><code>null</code> ， 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 <code>null</code> 与 <code>Null</code>、<code>NULL</code>或变体<strong>完全不同</strong>。</li><li><code>undefined</code> ，和 null 一样是一个特殊的关键字，undefined 表示变量未定义时的属性。</li><li>数字（<code>Number</code>），整数或浮点数，例如： 42 或者 3.14159。</li><li>任意精度的整数 (<code>BigInt</code>) ，可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。</li><li>字符串（<code>String</code>），字符串是一串表示文本值的字符序列，例如：”Howdy” 。</li><li>代表（<code>Symbol</code>） ( 在 ECMAScript 6 中新添加的类型).。一种实例是唯一且不可改变的数据类型。</li></ol><ul><li>以及对象（<code>Object</code>）。</li></ul><h3 id="运算细节"><a href="#运算细节" class="headerlink" title="运算细节"></a>运算细节</h3><p>你可以使用 <code>undefined</code> 来判断一个变量是否已赋值</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> input;<br><span class="hljs-keyword">if</span>(input === <span class="hljs-literal">undefined</span>)&#123;<br>  doThis();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  doThat();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>undefined</code> 值在布尔类型环境中会被当作 <code>false</code></p><p>数值类型环境中 <code>undefined</code> 值会被转换为 <code>NaN</code></p><p>当你对一个 <code>null</code> 变量求值时，空值 <code>null</code> 在数值类型环境中会被当作<code>0</code>来对待，而布尔类型环境中会被当作 <code>false</code></p><p>在包含的数字和字符串的表达式中使用加法运算符（+），JavaScript 会把数字转换成字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">x = <span class="hljs-string">"The answer is "</span> + <span class="hljs-number">42</span> <span class="hljs-comment">// "The answer is 42"</span><br>y = <span class="hljs-number">42</span> + <span class="hljs-string">" is the answer"</span> <span class="hljs-comment">// "42 is the answer"</span><br></code></pre></td></tr></table></figure><p>在涉及其它运算符（译注：如下面的减号’-‘）时，JavaScript语言不会把数字变为字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-string">"37"</span> - <span class="hljs-number">7</span> <span class="hljs-comment">// 30</span><br><span class="hljs-string">"37"</span> + <span class="hljs-number">7</span> <span class="hljs-comment">// "377"</span><br></code></pre></td></tr></table></figure><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>对象字面值是封闭在花括号对({})中的一个对象的零个或多个”属性名-值”对的（元素）列表。</p><p>对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的javascript标识符，它必须用””包裹。属性的名字不合法，那么便不能用.访问属性值，而是通过类数组标记(“[]”)访问和赋值。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> unusualPropertyNames = &#123;<br>  <span class="hljs-string">""</span>: <span class="hljs-string">"An empty string"</span>,<br>  <span class="hljs-string">"!"</span>: <span class="hljs-string">"Bang!"</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(unusualPropertyNames.<span class="hljs-string">""</span>);   <span class="hljs-comment">// 语法错误: Unexpected string</span><br><span class="hljs-built_in">console</span>.log(unusualPropertyNames[<span class="hljs-string">""</span>]);  <span class="hljs-comment">// An empty string</span><br><span class="hljs-built_in">console</span>.log(unusualPropertyNames.!);    <span class="hljs-comment">// 语法错误: Unexpected token !</span><br><span class="hljs-built_in">console</span>.log(unusualPropertyNames[<span class="hljs-string">"!"</span>]); <span class="hljs-comment">// Bang!</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">"alpha"</span>, <span class="hljs-number">2</span>: <span class="hljs-string">"two"</span>&#125;;<br><span class="hljs-built_in">console</span>.log(foo.a);    <span class="hljs-comment">// alpha</span><br><span class="hljs-built_in">console</span>.log(foo[<span class="hljs-number">2</span>]);   <span class="hljs-comment">// two</span><br><span class="hljs-comment">//console.log(foo.2);  // SyntaxError: missing ) after argument list</span><br><span class="hljs-comment">//console.log(foo[a]); // ReferenceError: a is not defined</span><br><span class="hljs-built_in">console</span>.log(foo[<span class="hljs-string">"a"</span>]); <span class="hljs-comment">// alpha</span><br><span class="hljs-built_in">console</span>.log(foo[<span class="hljs-string">"2"</span>]); <span class="hljs-comment">// two</span><br></code></pre></td></tr></table></figure><p>ES2015新增模板字面量，直接打印出多行字符串。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Roses are red,</span><br><span class="hljs-string">Violets are blue.</span><br><span class="hljs-string">Sugar is sweet,</span><br><span class="hljs-string">and so is foo.`</span>)<br></code></pre></td></tr></table></figure><h2 id="流程控制与错误处理"><a href="#流程控制与错误处理" class="headerlink" title="流程控制与错误处理"></a>流程控制与错误处理</h2><h3 id="判断语句的小细节"><a href="#判断语句的小细节" class="headerlink" title="判断语句的小细节"></a>判断语句的小细节</h3><p><strong>其值不是undefined或null的任何对象（包括其值为false的布尔对象）在传递给条件语句时都将计算为true</strong></p><p>这里我们以<strong>Boolean对象</strong>为例子：<br>如果需要，作为第一个参数传递的值将转换为布尔值。如果省略或值<code>0，-0，null，false，NaN，undefined</code>，或空字符串（<code>&quot;&quot;</code>），该对象具有的初始值<code>false</code>。所有其他值，包括任何对象，空数组（<code>[]</code>）或字符串<code>&quot;false&quot;</code>，都会创建一个初始值为的对象<code>true</code>。</p><p>注意不要将基本类型中的布尔值 <code>true</code> 和 <code>false</code> 与值为 <code>true</code> 和 <code>false</code> 的 <code>Boolean</code> 对象弄混了,<strong>不要在应该使用基本类型布尔值的地方使用 Boolean 对象</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> un;<br><span class="hljs-comment">//undifined</span><br><span class="hljs-keyword">if</span> (un)&#123;<br>    <span class="hljs-comment">//这里的代码不会被执行</span><br>    <span class="hljs-built_in">console</span>.log(un);<br>&#125; <br><br>un=<span class="hljs-literal">null</span>;<br><span class="hljs-comment">//null</span><br><span class="hljs-keyword">if</span> (un)&#123;<br>    <span class="hljs-comment">//这里的代码不会被执行</span><br>    <span class="hljs-built_in">console</span>.log(un);<br>&#125; <br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">if</span> (b)&#123;<br>    <span class="hljs-comment">//这里的代码会被执行</span><br>    <span class="hljs-built_in">console</span>.log(b.toString());<br>&#125; <br><span class="hljs-keyword">let</span> a= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">"false"</span>);<br><span class="hljs-keyword">if</span>(a)&#123;<br>    <span class="hljs-comment">//这里的代码会被执行</span><br>    <span class="hljs-built_in">console</span>.log(a.toString());<span class="hljs-comment">//会打印出false</span><br>&#125;<br><br><span class="hljs-keyword">let</span> x = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (x) &#123;<br>    <span class="hljs-comment">// 这里的代码不会执行</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"false"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正确使用途径</strong><br>不要用创建 <code>Boolean</code> 对象的方式将一个非布尔值转化成布尔值，直接将 <code>Boolean</code> 当做转换函数来使用即可，或者使用双重非（<code>!!</code>）运算符：</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-built_in">Boolean</span>(expression);     <span class="hljs-comment">// 推荐</span><br><span class="hljs-keyword">var</span> x = !!(expression);          <span class="hljs-comment">// 推荐</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(expression); <span class="hljs-comment">// 不太好</span><br></code></pre></td></tr></table></figure><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>同java，c++</p><h3 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h3><p>你可以用 <code>throw</code> 语句抛出一个异常并且用 <code>try...catch</code> 语句捕获处理它。同Java语法差不多。</p><h2 id="循环与迭代"><a href="#循环与迭代" class="headerlink" title="循环与迭代"></a>循环与迭代</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>foreach里面不支持break,continue,</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array1 = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];<span class="hljs-comment">//数组的类型其实也是对象</span><br>array1.forEach(<span class="hljs-function">(<span class="hljs-params">element,index</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(element,index));<br></code></pre></td></tr></table></figure><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p>for…in 语句循环一个指定的变量来循环一个<strong>对象</strong>所有<strong>可枚举的属性</strong>。JavaScript 会为每一个不同的属性执行指定的语句。</p><h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>for…of 语句在<strong>可迭代对象</strong>（包括<code>Array、Map、Set、arguments</code> 等等）上创建了一个循环，对值的每一个独特属性调用一次迭代,<strong>对象属于object，不可迭代</strong>。<br><img src="/2020/09/26/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/3.png" alt="对象不可迭代"><br><strong>所以for of 则无法迭代js的object属性值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>];<br>arr.foo = <span class="hljs-string">"hello"</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;<br>   <span class="hljs-built_in">console</span>.log(i,arr[i]); <br>   <span class="hljs-comment">// 输出 "0 3", "1 5", "2 7", "foo hello"</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;<br>   <span class="hljs-built_in">console</span>.log(i); <span class="hljs-comment">// 输出 "3", "5", "7"</span><br>&#125;<br><br><span class="hljs-comment">// 注意 for...of 的输出没有出现 "hello"</span><br></code></pre></td></tr></table></figure><p><img src="/2020/09/26/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/2.png" alt="好好理解"><br>for … in循环将把foo包括在内了，但Array的length属性却不包括在内，所以length还是3.</p><p><img src="/2020/09/26/js%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5/1.png" alt="好好理解"><br>这是MDN官方文档的解释，多看几遍就能理解，其实for in会把array作为一个对象来打迎打所有的属性，而for of则只对可迭代的对象进行遍历，也就是这里面的array了，这也能解释为什么foreach也只能打印数组元素了。</p><p>两者区别参考了博客<a href="https://blog.csdn.net/IUBKBK/article/details/90962430?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight" target="_blank" rel="noopener">for…in和for…of的用法与区别1</a>和<a href="https://blog.csdn.net/IUBKBK/article/details/90962430?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight" target="_blank" rel="noopener">for…in和for…of的用法与区别2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将记录学习JavaScript(包含有ES)语法基础,主要来自&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN&lt;/a&gt;的官方文档&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web基础" scheme="https://yoursite.com/tags/web%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>htmlcss回顾</title>
    <link href="https://yoursite.com/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/"/>
    <id>https://yoursite.com/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/</id>
    <published>2020-09-24T13:15:00.000Z</published>
    <updated>2021-01-19T04:31:34.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="html回顾"><a href="#html回顾" class="headerlink" title="html回顾"></a>html回顾</h2><p>重回前端，文章是记录的<a href="https://developer.mozilla.org/zh-CN/docs/Web" target="_blank" rel="noopener">MDN Web Doc</a>和<a href="http://www.lvyestudy.com/les_cj/css_list.aspx" target="_blank" rel="noopener">绿叶学习网</a>的相关内容笔记。这里不会把基础知识列出来，这里主要是记录一些自己有新体会的东西。</p><a id="more"></a><p>HTML 不是一门编程语言，而是一种用于定义内容结构的标记语言，超文本标记语言 (英语：Hypertext Markup Language，简称：HTML ) 是一种用来结构化 Web 网页及其内容的标记语言。</p><h3 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源策略</a>是一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E6%BA%90" target="_blank" rel="noopener">origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p><p>如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p><p>下表给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p><table><thead><tr><th align="center">URL</th><th align="center">结果</th><th align="center">原因</th></tr></thead><tbody><tr><td align="center"><code>http://store.company.com/dir2/other.html</code></td><td align="center">同源</td><td align="center">只有路径不同</td></tr><tr><td align="center"><code>http://store.company.com/dir/inner/another.html    </code></td><td align="center">同源</td><td align="center">只有路径不同</td></tr><tr><td align="center"><code>https://store.company.com/secure.html</code></td><td align="center">失败</td><td align="center">协议不同</td></tr><tr><td align="center"><code>http://store.company.com:81/dir/etc.html</code></td><td align="center">失败</td><td align="center">端口不同 ( http:// 默认端口是80)</td></tr><tr><td align="center"><code>http://news.company.com/dir/other.html</code></td><td align="center">失败</td><td align="center">主机不同</td></tr></tbody></table><h3 id="插入图片不推荐方式"><a href="#插入图片不推荐方式" class="headerlink" title="插入图片不推荐方式"></a>插入图片不推荐方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.example.com/images/dinosaur.jpg"</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方式是不被推荐的，这样做只会使浏览器做更多的工作，例如重新通过 DNS 再去寻找 IP 地址。通常我们都会把图片和 HTML 放在同一个服务器上。</p><p>有一个<strong>更好的做法</strong>是使用 HTML5 的<code>&lt;figure&gt;</code>和 <code>&lt;figcaption&gt;</code> 元素，它正是为此而被创造出来的：为图片提供一个语义容器，在标题和图片之间建立清晰的关联。我们之前的例子可以重写为:</p><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg"</span></span><br><span class="hljs-tag">     <span class="hljs-attr">alt</span>=<span class="hljs-string">"一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。"</span></span><br><span class="hljs-tag">     <span class="hljs-attr">width</span>=<span class="hljs-string">"400"</span></span><br><span class="hljs-tag">     <span class="hljs-attr">height</span>=<span class="hljs-string">"341"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>曼彻斯特大学博物馆展出的一只霸王龙的化石<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="lt-input-gt"><a href="#lt-input-gt" class="headerlink" title="&lt;input&gt;"></a><code>&lt;input&gt;</code></h3><h3 id="formenctype属性"><a href="#formenctype属性" class="headerlink" title="formenctype属性"></a>formenctype属性</h3><p>由于input元素是一个提交按钮，因此该formenctype属性指定用于向服务器提交表单的内容类型。可能的值为：</p><ul><li>application/x-www-form-urlencoded：如果未指定属性，则为默认值。</li><li>multipart/form-data：如果<code>&lt;input&gt;</code>使用type属性设置为的元素，则使用此值file。</li><li>text/plain</li></ul><p>如果指定了此属性，它将覆盖<code>enctype</code>元素的表单所有者的属性。</p><h3 id="form属性"><a href="#form属性" class="headerlink" title="form属性"></a>form属性</h3><p>与按钮关联的表单元素（其表单所有者）。该属性的值必须是同一文档中元素的id属性<code>&lt;form&gt;</code>。如果未指定此属性，则该<code>&lt;button&gt;</code>元素必须是form元素的后代。此属性使您可以将<code>&lt;button&gt;</code>元素放置在文档中的任何位置，而不仅仅是<code>&lt;form&gt;</code>元素的后代。</p><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>按钮的名称，与表单数据一起提交。</p><h3 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h3><p>按钮的类型。可能的值为：<br><strong>submit</strong>：按钮将表单数据提交到服务器。如果未指定属性，或者该属性动态更改为空或无效值，则这是默认设置。<br><strong>reset</strong>：按钮将所有控件重置为其初始值。<br><strong>button</strong>：该按钮没有默认行为。它可以具有与元素的事件相关联的客户端脚本，这些脚本在事件发生时触发。  </p><h3 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h3><p>按钮的初始值。</p><h2 id="元素的id和class"><a href="#元素的id和class" class="headerlink" title="元素的id和class"></a>元素的id和class</h2><h3 id="元素的id属性"><a href="#元素的id属性" class="headerlink" title="元素的id属性"></a>元素的id属性</h3><p>id属性被赋予了标识页面元素的唯一身份。如果一个页面出现了多个相同id属性取值，CSS选择器或者JavaScript就会因为无法分辨要控制的元素而最终报错。</p><h3 id="元素的class属性"><a href="#元素的class属性" class="headerlink" title="元素的class属性"></a>元素的class属性</h3><p>如果你要为两个元素或者两个以上元素定义相同的样式，建议使用class属性。</p><p><strong>（1）一个标签可以同时定义多个class；</strong><br><strong>（2）id也可以写成name，区别在于name是HTML中的标准，而id是XHTML中的标准，现在网页的标准都是使用id，所以大家尽量不要用name属性；</strong></p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>1.元素选择器<br><img src="/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/1.png" alt="元素选择器"><br>2.id选择器<br><img src="/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/2.png" alt="id选择器"><br>3.class选择器<br><img src="/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/3.png" alt="class选择器"><br>4.子元素选择器<br>子元素选择器，就是选中某个元素下的子元素，然后对该子元素设置CSS样式。<br><img src="/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/4.png" alt="子元素选择器"><br>5.相邻选择器<br>相邻选择器，就是选中该元素的下一个兄弟元素，在这里注意一点，相邻选择器的操作对象是该元素的同级元素。<br><img src="/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/5.png" alt="相邻选择器"><br>6.群组选择器<br>群组选择器，就是同时对几个选择器进行相同的操作。<br><img src="/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/6.png" alt="群组选择器"><br>7.全局选择器<br>全局选择器，是由一个星号（<code>*</code>）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容，比如，它紧随在其他元素以及邻代运算符之后的时候）下面的示例中，我们已经用全局选择器，移去了所有元素上的外边距</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一些新用法<br><img src="/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/8.png" alt="8"><br><img src="/2020/09/24/htmlcss%E5%9B%9E%E9%A1%BE/9.png" alt="9"></p><h2 id="before和-after"><a href="#before和-after" class="headerlink" title="::before和::after"></a>::before和::after</h2><p><code>::before</code>和<code>::after</code>伪元素与<code>content</code>属性的共同使用，在CSS中被叫做“生成内容”</p><h2 id="text-align属性"><a href="#text-align属性" class="headerlink" title="text-align属性"></a>text-align属性</h2><p>在CSS中，使用text-align属性控制文本的水平方向的对齐方式：左对齐、居中对齐、右对齐。</p><p><strong>text-align属性不仅对文本文字有效，对img标签也有效，但是对其他标签无效。</strong></p><table><thead><tr><th align="center">text-align属性值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">left</td><td align="center">默认值，左对齐</td></tr><tr><td align="center">center</td><td align="center">居中对齐</td></tr><tr><td align="center">right</td><td align="center">右对齐</td></tr></tbody></table><h2 id="块元素和行内元素"><a href="#块元素和行内元素" class="headerlink" title="块元素和行内元素"></a>块元素和行内元素</h2><p>1、HTML元素根据浏览器表现形式分为两类：块元素，行内元素；</p><p>2、块元素特点：</p><ul><li>独占一行，排斥其他元素跟其位于同一行，包括块元素和行内元素；</li><li>块元素内部可以容纳其他块元素或行元素；</li></ul><table><thead><tr><th align="center">块元素</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">div</td><td align="center">div层</td></tr><tr><td align="center">h1～h6</td><td align="center">1到6级标题</td></tr><tr><td align="center">p    段落</td><td align="center">会自动在其前后创建一些空白</td></tr><tr><td align="center">hr</td><td align="center">分割线</td></tr><tr><td align="center">ol</td><td align="center">有序列表</td></tr><tr><td align="center">ul</td><td align="center">无序列表</td></tr><tr><td align="center">3、行内元素特点：</td><td align="center"></td></tr></tbody></table><ul><li>可以与其他行内元素位于同一行；</li><li>行内内部可以容纳其他行内元素，但不可以容纳块元素，不然会出现无法预知的效果；</li></ul><table><thead><tr><th align="center">行内元素</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">strong</td><td align="center">加粗强调</td></tr><tr><td align="center">em</td><td align="center">斜体强调</td></tr><tr><td align="center">s</td><td align="center">删除线</td></tr><tr><td align="center">u</td><td align="center">下划线</td></tr><tr><td align="center">a</td><td align="center">超链接</td></tr><tr><td align="center">span</td><td align="center">常用行级，可定义文档中的行内元素</td></tr><tr><td align="center">img</td><td align="center">图片</td></tr><tr><td align="center">input</td><td align="center">表单</td></tr></tbody></table><h2 id="CSS边框（border）"><a href="#CSS边框（border）" class="headerlink" title="CSS边框（border）"></a>CSS边框（border）</h2><p>任何块元素和行内元素都可以设置边框属性。<br>设置一个元素的边框必须要同时设置border-width、border-style、border-color这三个属性，这个元素的边框才能在浏览器显示出来。</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">border-width</span><span class="hljs-selector-pseudo">:1px</span>;<br><span class="hljs-selector-tag">border-style</span><span class="hljs-selector-pseudo">:solid</span>;<br><span class="hljs-selector-tag">border-color</span><span class="hljs-selector-pseudo">:Red</span>;<br><span class="hljs-comment">/*简介写法*/</span><br><span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">Red</span>;<br></code></pre></td></tr></table></figure><p>在CSS中，我们可以分别针对上下左右四条边框设置单独的样式。</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">border-top-width</span><span class="hljs-selector-pseudo">:1px</span>;<br><span class="hljs-selector-tag">border-top-style</span><span class="hljs-selector-pseudo">:solid</span>;<br><span class="hljs-selector-tag">border-top-color</span><span class="hljs-selector-pseudo">:red</span>;<br><span class="hljs-comment">/*简介写法*/</span><br><span class="hljs-selector-tag">border-top</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">Red</span>;<br><span class="hljs-selector-tag">border-bottom</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">Red</span>;<br><span class="hljs-selector-tag">border-left</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">Red</span>;<br><span class="hljs-selector-tag">border-right</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">Red</span>;<br><br><span class="hljs-comment">/*去除边框的两种方法*/</span><br><span class="hljs-selector-tag">border-bottom</span><span class="hljs-selector-pseudo">:0px</span> <span class="hljs-comment">/*去除边框就不需要写颜色和样式了*/</span><br><span class="hljs-selector-tag">border-bottom</span><span class="hljs-selector-pseudo">:none</span><br></code></pre></td></tr></table></figure><h2 id="css背景样式background"><a href="#css背景样式background" class="headerlink" title="css背景样式background"></a>css背景样式background</h2><p>目前，不要再使用HTML的bgcolor之类的属性了，现在几乎全部都是使用CSS的background属性来控制元素的背景颜色和背景图像。<br>1.背景颜色<br>使用css的background-color属性<br>2.背景图像  </p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">background-image</td><td align="center">定义背景图像的路径，这样图片才能显示</td></tr><tr><td align="center">background-repeat</td><td align="center">定义背景图像显示方式，例如纵向平铺、横向平铺</td></tr><tr><td align="center">background-position</td><td align="center">定义背景图像在元素哪个位置</td></tr><tr><td align="center">background-attachment</td><td align="center">定义背景图像是否随内容而滚动</td></tr></tbody></table><h2 id="img适合框大小"><a href="#img适合框大小" class="headerlink" title="img适合框大小"></a>img适合框大小</h2><p><code>object-fit</code>属性可以在这里帮助你。当使用object-fit时，替换元素可以以多种方式被调整到合乎盒子的大小。</p><h2 id="布局样式"><a href="#布局样式" class="headerlink" title="布局样式"></a>布局样式</h2><p>主要是通过<code>display</code>属性来操作，一般有<code>block,inline,inline-block,grid,flex,none</code>这几种操作，具体的使用还是需要多练习才能明白。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;html回顾&quot;&gt;&lt;a href=&quot;#html回顾&quot; class=&quot;headerlink&quot; title=&quot;html回顾&quot;&gt;&lt;/a&gt;html回顾&lt;/h2&gt;&lt;p&gt;重回前端，文章是记录的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN Web Doc&lt;/a&gt;和&lt;a href=&quot;http://www.lvyestudy.com/les_cj/css_list.aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;绿叶学习网&lt;/a&gt;的相关内容笔记。这里不会把基础知识列出来，这里主要是记录一些自己有新体会的东西。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web基础" scheme="https://yoursite.com/tags/web%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="https://yoursite.com/2020/09/21/%E8%BF%9B%E7%A8%8B/"/>
    <id>https://yoursite.com/2020/09/21/%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-09-21T15:41:53.000Z</published>
    <updated>2021-01-19T04:31:32.932Z</updated>
    
    <content type="html"><![CDATA[<p>进程是支持程序执行的机制，可以理解为程序对数据或请求的处理过程，是一个独立功能的程序关于数据集合的一次运动活动，是操作系统进行资源分配的一个单位。在介绍相关知识之前，首先我们需要了解几个重要概念。<br>进程实体主要包含PCB，程序段，数据段三个部分构成进程实体又称进程映像。<br>PCB是指系统为每个运行的程序分配了一个数据结构被称为进程控制块。PCB是进程存在的唯一标志，创建进程和撤销进程实质上都是创建和撤销PCB。<br>进程实体是静态的指进程三要素存放的数据，而进程是一个动态执行的过程，一般我们不区分进程和进程实体的概念，所以也可以说进程是由PCB，程序段，数据段组成。</p><a id="more"></a><h2 id="进程状态和控制切换"><a href="#进程状态和控制切换" class="headerlink" title="进程状态和控制切换"></a>进程状态和控制切换</h2><p><img src="https://img-blog.csdnimg.cn/20201021182848869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201021183311404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信顾名思义是指进程之间的信息交换，有三种方式，共享存储，消息传递，管道通信。各进程拥有的内存地址空间是独立的，为了保证安全，一个进程是不能直接访问另外一个进程的内存地址的。</p><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p><img src="https://img-blog.csdnimg.cn/20201021184958623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p><img src="https://img-blog.csdnimg.cn/20201021185526441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>消息传递主要是通过发送和接受原语，主要有两种方式，一种是直接通信方式，消息会直接发送到对方的消息队列中，一种是间接通信方式，消息先放到中间信箱中存储。<br><img src="https://img-blog.csdnimg.cn/20201021185731868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程是CPU的基本执行单元，也是程序执行流的最小单位</strong>。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。</p><h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则:<br>1．空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区;<br>2． 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待;<br>3．有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）<br>4． 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p><p><img src="https://img-blog.csdnimg.cn/20201021200330944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p><img src="https://img-blog.csdnimg.cn/20201021221625620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2tfX19F,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程是支持程序执行的机制，可以理解为程序对数据或请求的处理过程，是一个独立功能的程序关于数据集合的一次运动活动，是操作系统进行资源分配的一个单位。在介绍相关知识之前，首先我们需要了解几个重要概念。&lt;br&gt;进程实体主要包含PCB，程序段，数据段三个部分构成进程实体又称进程映像。&lt;br&gt;PCB是指系统为每个运行的程序分配了一个数据结构被称为进程控制块。PCB是进程存在的唯一标志，创建进程和撤销进程实质上都是创建和撤销PCB。&lt;br&gt;进程实体是静态的指进程三要素存放的数据，而进程是一个动态执行的过程，一般我们不区分进程和进程实体的概念，所以也可以说进程是由PCB，程序段，数据段组成。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
